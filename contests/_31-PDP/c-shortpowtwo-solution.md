---
layout: solution
codename: shortpowtwo
---

## Ζητούμενο

Μας δίνεται ένα γράφημα με $$N$$ κόμβους και $$M$$ ακμές, και ζητείται η ελάχιστη απόσταση μεταξύ δύο κόμβων $$S$$ και $$T$$ (modulo $$10^{9}+7$$). Η μόνη διαφορά από το γνωστό πρόβλημα ελάχιστου μονοπατιού είναι ότι τα βάρη των ακμών είναι πολύ μεγάλα. Για την ακρίβεια, είναι πάντα δυνάμεις του $$2$$, κι έτσι το input μας δίνει απλά τον εκθέτη τους (το πολύ $$w$$).

Οι γνώσεις που χρειάζονται για τα πρώτα $$3$$ subtasks είναι ο αλγόριθμος [Dijkstra](https://cp-algorithms.com/graph/dijkstra.html) (δείτε [εδώ](https://cp-algorithms.com/graph/dijkstra_sparse.html) για μία αποδοτικότερη υλοποίηση, και [εδώ](https://visualgo.net/en/sssp?slide=1) για μία διαδραστική οπτικοποίηση του αλγορίθμου).

Το τέταρτο subtask ήταν ιδιαίτερα απαιτητικό, και απαιτεί τη γνώση [hashing](https://cp-algorithms.com/string/string-hashing.html) και Persistent Segment Trees (δείτε [εδώ](https://cp-algorithms.com/data_structures/segment_tree.html#toc-tgt-12), [εδώ](https://blog.anudeep2011.com/persistent-segment-trees-explained-with-spoj-problems/) ή, αν προτιμάτε τις δικές μας επεξηγήσεις, [εδώ](/assets/persistency-rap-solution.pdf), όπου συζητείται η λύση [αυτού](http://www.hellenico.gr/contest/task.php?name=rap) του προβλήματος-εφαρμογής Persistency). Υπενθυμίζουμε ότι το παρόν site δε φιλοδοξεί να παρουσιάσει με λεπτομέρεια τις τεχνικές αυτές, αλλά επιχειρεί να δείξει πώς, γνωρίζοντάς τες, μπορούμε να λύσουμε τα προβλήματα που ζητάει ο ΠΔΠ.

Λόγω αυξημένης δυσκολίας του τέταρτου subtask, θα σας προτείναμε να ασχοληθείτε μαζί του μόνο όταν αποκτήσετε μεγάλη εξοικίωση με την τεχνική Persistency.

## Λύση πολυπλοκότητας $$\mathcal{O}(N^{2})$$ (εάν $$w \le 10$$)
Στο πρώτο subtask ο εκθέτης $$w$$ είναι το πολύ $$10$$, δηλαδή το βάρος κάθε ακμής είναι το πολύ $$2^{10}=1024$$. Επιπλέον το γράφημα είναι αρκετά μικρό, κι έτσι αρκεί αρκεί ένας απλός [Dijkstra](https://cp-algorithms.com/graph/dijkstra.html) σε χρόνο $$\mathcal{O}(N^2)$$. Εάν δεν έχετε ξανακούσει τον αλγόριθμο, μπορείτε να πειραματιστείτε [εδώ](https://visualgo.net/en/sssp) για να δείτε πώς λειτουργεί.

**Σημείωση:** Δοθέντος $$w$$, υπολογίζουμε το $$2^{w}$$ είτε με μία for-loop, είτε απλώς με την εντολή της $$C++$$ `(1<<w)`. Αν δεν ξέρετε πώς δουλεύει αυτό, μπορείτε να δείτε το [lottery](/31-PDP/c-lottery-solution) (31ος ΠΔΠ, Γ Φάση).

Μία ενδεικτική υλοποίηση φαίνεται παρακάτω:

{% include code.md solution_name='shortpowtwo_n2_small_w.cc' %}

## Λύση πολυπλοκότητας $$\mathcal{O}(M\log{N})$$ (εάν $$w \le 10$$)

Στο δεύτερο subtask ο εκθέτης $$w$$ παραμένει το πολύ $$10$$, αλλά το γράφημα είναι πολύ μεγαλύτερο. Έτσι χρειάζεται να τρέξουμε [Dijkstra](https://cp-algorithms.com/graph/dijkstra_sparse.html) υλοποιημένο με set, πολυπλοκότητας $$\mathcal{O}(M\log{N})$$.

Μία ενδεικτική υλοποίηση φαίνεται παρακάτω:

{% include code.md solution_name='shortpowtwo_mlogn_small_w.cc' %}

## Λύση πολυπλοκότητας $$\mathcal{O}(Mw\log{N})$$ για οποιοδήποτε $$w$$

Αφού η κάθε ακμή έχει βάρος το πολύ $$2^{w}$$, άρα το μέγιστο μονοπάτι μπορεί να έχει μήκος έως και $$(N-1) 2^{w}$$, δηλαδή περίπου $$2^{520}$$ για το τρίτο subtask. Αυτό είναι πολύ μεγάλο και δε χωράει σε αριθμούς $$long~long$$. Αν κοιτάξουμε λίγο καλύτερο στον αλγόριθμο Dijkstra, θα δούμε ότι χρειαζόμαστε δύο μόνο πράξεις με αριθμούς που μπορεί να έχουν μέχρι και $$520$$ ψηφία στο δεκαδικό σύστημα.

1. Σύγκριση $$a < b$$, όπου $$a$$ και $$b$$ ακέραιοι με $$520$$ ψηφία ο καθένας.
2. Πρόσθεση $$a + b$$, όπου $$a$$ ακέραιος με $$520$$ ψηφία, και $$b$$ δύναμη του $$2$$ (ως βάρος ακμής).

Αν για κάθε αριθμό κρατάμε ένα πίνακα με $$520$$ θέσεις (μία για κάθε δυαδικό ψηφίο του αριθμού) τότε αρκεί να υλοποιήσουμε τις παραπάνω πράξεις.

Σχετικά με τη σύγκριση, απλώς ξεκινάμε από το σημαντικότερο ψηφίο των αριθμών (αυτό στη θέση $$520$$) και προχωράμε προς το λιγότερο σημαντικό ψηφίο. Την πρώτη στιγμή που θα εντοπίσουμε ότι σε κάποια θέση οι δύο αριθμοί διαφέρουν, αντιλαμβανόμαστε ότι μεγαλύτερος είναι αυτός που έχει ψηφίο $$1$$ και μικρότερος αυτός που έχει ψηφίο $$0$$ (αυτές είναι οι μόνες δύο επιλογές αφού δουλεύουμε σε δυαδικό σύστημα).

Παρακάτω δίνουμε το κομμάτι του κώδικα που υλοποιεί τους μεγάλους αριθμούς και τη σύγκρισή τους.

{% include code.md solution_name='shortpowtwo_mwlogn.cc' start=9 end=21 %}

Σημειώνουμε ότι ορίσαμε τον πίνακα με λίγες παραπάνω θέσεις ($$530$$) για ασφάλεια. Επιπλέον, μπορεί να σας τρομάξει ο τρόπος που ορίζουμε τη σύγκριση (συνάρτηση operator μέσα σε struct δεν είναι και ό,τι πιο συνηθισμένο). Τα καλά αυτού του τρόπου είναι ότι αργότερα μπορούμε μέσα στον κώδικα να ορίσουμε δύο BigNum αριθμούς `BigNum A,B`, και να τους συγκρίνουμε φυσιολογικά με `A<B`. Επιπλέον, με τον τρόπο αυτό μπορούμε να ορίσουμε ένα $$set$$, όπως χρειάζεται ο Dijkstra, και αυτό θα ξερει αυτόματα πώς να οργανωθεί εσωτερικά (χωρίς εμείς να ξέρουμε πώς) ώστε να μας παρέχει γρήγορα τις πράξεις που χρειαζόμαστε.

Η πρόσθεση ενός αριθμού $$BigNum~A$$ με έναν $$B$$ που είναι δύναμη του $$2$$ (πχ $$B=2^{c}$$) είναι κάπως ενδιαφέρουσα. Πρώτα από όλα, όπως στο δεκαδικό σύστημα το $$10^5$$ έχει ένα άσσο στη θέση 5 και παντού αλλού μηδενικά, έτσι και το $$2^{c}$$ στο δυαδικό σύστημα έχει ένα άσσο στη θέση $$c$$ και παντού αλλού μηδενικά. Κατά τα άλλα συνεχίζουμε όπως στο δεκαδικό σύστημα. Δηλαδή αυξάνουμε κατά ένα τη θέση $$c$$ του $$A$$, και αν υπάρχει κρατούμενο το προχωράμε στη θέση $$c+1$$, κλπ.

Το ενδιαφέρον είναι ότι επειδή δουλεύουμε στο δυαδικό σύστημα, δεν υπάρχουν πολλές επιλογές. Αν ο αριθμός $$A$$ έχεις άσσους από τη θέση $$c$$ ως κάποια μεγαλύτερη θέση (πχ τη θέση $$c+10$$) και μετά έχει μηδενικό (πχ στη θέση $$c+11$$), τότε αυτή η προώθηση του κρατουμένου θα μηδενίσει όλους τους άσσους στις θέσεις $$c \ldots c+10$$, και θα κάνει άσσο τη θέση $$c+11$$. Επομένως ο κώδικας για την πρόσθεση είναι ο παρακάτω, και χρησιμοποιεί το γεγονός ότι για να αντιστρέψουμε μία δυαδική τιμή $$a$$, μπορούμε να κάνουμε `a = a^1;`, ή αλλιώς `a ^= 1;`, καθώς το `^` είναι ο τελεστής $$XOR$$ στη $$C++$$:

{% include code.md solution_name='shortpowtwo_mwlogn.cc' start=23 end=32 %}

Αφού οι δύο πράξεις που ζητάμε υλοποιούνται σε γραμμικό χρόνο ως προς το $$w$$ (μέγιστο εκθέτη), έτσι η τελική πολυπλοκότητα είναι ίδια με αυτή του Dijkstra, πολλαπλασιασμένη με $$w$$ επειδή τόσο χρόνο θα κοστίζει πλέον η κάθε πράξη. Συνεπώς έχουμε πολυπλοκότητα $$\mathcal{O}(Mw\log{N})$$.

Ας σημειώσουμε κάτι τελευταίο. Επειδή καταλήγουμε να έχουμε έναν μεγάλο αριθμό, που είναι η πραγματική απάντηση, αλλά θέλουμε να πάρουμε το υπόλοιπο με το $$10^{9}+7$$, θα έπρεπε να υλοποιήσουμε και αυτή την πράξη! Αυτό το αποφεύγουμε με τον εξής τρόπο: Ο αλγόριθμος Dijkstra μπορεί να μας επιστρέψει και το ίδιο το μονοπάτι πέρα από το μήκος του. Αυτό συμβαίνει αν θυμόμαστε για κάθε κόμβο, ποιος ήταν ο ακριβώς προηγούμενός του στο μονοπάτι (λεπτομέρειες στον κώδικα). Έτσι, όταν τελειώσουμε με τον Dijkstra, μπορούμε να προχωρήσουμε πάνω σε αυτό το μονοπάτι, και να ξαναϋπολογίσουμε σιγά σιγά το μήκος του, αλλά αυτή τη σειρά κάνοντας την κάθε πράξη modulo $$10^{9}+7$$.

Μία ενδεικτική υλοποίηση φαίνεται παρακάτω:

{% include code.md solution_name='shortpowtwo_mwlogn.cc' %}

## Λύση πολυπλοκότητας $$\mathcal{O}(M\log{w}\log{N})$$

Για το τελευταίο subtask, το $$w$$ είναι πολύ μεγάλο. Επομένως θα πρέπει να βρούμε ένα πιο γρήγορο τρόπο να υλοποιήσουμε τις παραπάνω $$2$$ πράξεις. Θα υλοποιήσουμε λοιπόν τους $$BigNum$$ με διαφορετικό τρόπο.

Αρχικά θα υποθέσουμε ότι μπορούμε σε σταθερό χρόνο να δημιουργούμε ένα αντίγραφο ενός $$BigNum$$. Αυτό θα γίνει αξιοποιώντας την τεχνική Persistency, καθώς εξ' ορισμού αυτό που μας δίνει είναι η δυνατότητα να τροποποιούμε πράγματα και να γνωρίζουμε πώς μοιάζαν τόσο πριν όσο μετά την τροποποίηση.

Παίρνουμε μία ιδέα για το τι δομή δεδομένων θα χρειαστούμε για την αναπαράσταση των $$BigNum$$, κοιτώντας την πρόσθεση μίας δύναμης του $$2$$ (έστω $$2^{c}$$) σε έναν $$BigNum~A$$. Η πρώτη μας δουλειά είναι να δημιουργήσουμε ένα αντίγραφο του $$A$$ το οποίο θα τροποποιήσουμε. Κατόπιν, όπως αναφέραμε, και νωρίτερα, αναζητούμε το πρώτο μηδενικό που βρίσκεται από τη θέση $$c$$ και μετά. Τέλος, αντιστρέφουμε ό,τι βρίσκεται στις θέσεις μεταξύ $$c$$ και του πρώτου μηδενικό από τη θέση $$c$$ και μετά. Εφόσον χρειαζόμαστε μαζικές ανανεώσεις, το μυαλό μας πάει κατευθείαν σε ένα Segment Tree με Lazy Propagation (τα link για το persistency καλύπτουν και αυτές τις τεχνικές). Όπως λοιπόν πριν είχαμε ένα πίνακα με $$w+30$$ θέσεις, τώρα θα έχουμε ένα Segment Tree με $$w+30$$ θέσεις. Σημειώνουμε ότι εφαρμόζωντας persistency, εξ ορισμού, η τροποποίηση του $$A$$ δεν καταστρέφει τον αρχικό $$A$$, κι έτσι είναι σαν να πήραμε δωρεάν ένα αντίγραφο το οποίο τροποποιήσαμε.

Σχετικά με τη σύγκριση δύο μεγάλων αριθμών, ζητάμε απλώς να βρούμε τη μέγιστη θέση στην οποία διαφέρουν. Κατόπιν θα ελέγξουμε απλώς αυτή τη θέση. Για να το πετύχουμε αυτό, κρατάμε μία hash-value σε κάθε κόμβο, που περιγράφει τα ψηφία που έχει από κάτω του. Έτσι, όταν έχουμε δύο αριθμούς, ελέγχουμε αν το δεξί τους μισό είναι ίσο, κοιτώντας τα αντίστοιχα hash-values. Εάν διαφέρουν, ασχολούμαστε μόνο με το δεξί τους μισό, ενώ αν είναι ίσα, ασχολούμαστε μόνο με το αριστερό τους μισό.

Καταλήγουμε ότι κάθε κόμβος χρειάζεται να γνωρίζει μία hash-τιμή (που περιγράφει τι υπάρχει από κάτω του) και μία lazy-τιμή (που περιγράφει αν πρέπει να αντιστραφούν τα πάντα από κάτω του ή όχι). Τα φύλλα επίσης πρέπει να γνωρίζουν αν περιέχουν $$0$$ ή $$1$$, αλλά αυτό θα ταυτίζεται με τη hash-τιμή τους.

Πώς υλοποιείται το ερώτημα πρώτου μηδενικού από συγκεκριμένη θέση και μετά; Απλούστατα σπάμε το διάστημα αναζήτησης στα δύο, κοιτάμε για το πρώτο μηδενικό που βρίσκεται στο αριστερό διάστημα, κι αν δεν υπάρχει, επιστρέφουμε το πρώτο μηδενικό στο δεξί διάστημα. Τα segment trees μας εγγυόνται ότι μπορούμε να το πετύχουμε αυτό σε λογαριθμικό (ως προς το $$w$$) χρόνο.

Ως προς τη μαζική ανανέωση, εφαρμόζουμε lazy propagation. Η νέα hash-τιμή ενός κόμβου είναι ίση με το hash του αριστερού του παιδιού, συν κάτι ακόμα που μοιάζει με το hash του δεξιού παιδιού. Η μόνη διαφορά είναι ότι το hash του δεξιού παιδιού ξεκινάει τις δυνάμεις με εκθέτη $$0$$, ενώ θα έπρεπε να τις ξεκινάει με μεγαλύτερο εκθέτη (όσα τα στοιχεία του αριστερού παιδιού). Επομένως απλά πολλαπλασιάζουμε το hash του δεξιού παιδιού με την κατάλληλη δύναμη του $$2$$, και μετά το προσθέτουμε στο hash του αριστερού παιδιού.

Επιπλέον, ας προσέξουμε τι γίνεται όταν αντιστρέφουμε όλα τα ψηφία ενός αριθμού (πχ το $$010$$ γίνεται $$101$$). Αυτό είναι ισοδύναμο με το να πάρουμε τον αριθμό που έχει μόνο άσσους ($$111$$), και να του αφαιρέσουμε την παλιά τιμή. Πράγματι, στο συγκεκριμένο παράδειγμα βλέπουμε ότι ($$111-010 = 101$$ στο δυαδικό σύστημα). Όμως αν προσθέσουμε $$1$$ στον αριθμό που έχει μόνο άσσους, παίρνουμε μία δύναμη του $$2$$ ($$1000$$ στο δυαδικό, ίσο με $$8$$ στο δεκαδικό). Επομένως έχουμε $$(1000-1)-010 = 101$$. Αυτό το τρικ χρησιμοποιούμε και για να ανανεώσουμε το hash. Παίρνουμε το hash μιας δύναμης του $$2$$, αφαιρούμε 1, αφαιρούμε και το παλιό hash, και παίρνουμε το καινούργιο hash.