---
layout: solution
codename: pcr
---

## Επεξήγηση εκφώνησης

Μας δίνεται μία ακολουθία από ακεραίους $$\lbrace 0, 1, 2, 3 \rbrace$$. Μας ζητείται να βρούμε την *βέλτιστη* , δηλαδή τη μικρότερη σε μήκος (και σε περίπτωση ισοβαθμίας, την λεξικογραφικά μικρότερη), ακολουθία από push, reverse και complement, ώστε να μετατρέψουμε μία *αριστερή* ακολουθία σε μία *δεξιά* ακολουθία όπου όλα τα $$0$$, $$1$$, $$2$$ και $$3$$ είναι ομαδοποιημένα.

Ξεκινάμε με μία παρατήρηση που δεν είναι αναγκαία για την κατανόηση των παρακάτω λύσεων αλλά δίνει πληροφορίες για την διαδικασία.

**Παρατήρηση 0:** Για οποιαδήποτε δοσμένη αριστερή ακολουθία, υπάρχει μία τέτοια ακολουθία κινήσεων.

Αν οι αριθμοί ήταν $$0$$ και $$1$$, τότε μπορούμε να διατηρήσουμε την ακολουθία $$00\ldots 011 \ldots 1$$. Όποτε συναντάμε $$1$$ κάνουμε $$p$$, ενώ όποτε συναντάμε $$0$$ κάνουμε $$rpr$$ (δηλαδή το προσθέτουμε στα αριστερά). Αφού οι αριθμοί είναι από $$0$$ έως $$3$$, όποτε συναντάμε $$2$$ κάνουμε $$cpc$$ (προσθέτουμε $$1$$ στα δεξιά) και όποτε συναντάμε $$3$$ κάνουμε $$crprc$$ (προσθέτουμε $$0$$ στα αριστερά). Επομένως, πάντοτε υπάρχει μία τέτοια ακολουθία.

Κάνουμε τις εξής απλές παρατηρήσεις, οι οποίες είναι χρήσιμες για όλες τις παρακάτω λύσεις:

**Παρατήρηση 1:** Τα στοιχεία εισάγονται (γίνονται pushed) με τη σειρά της δοσμένης αριστερής ακολουθίας.

*(Αιτιολόγηση)* Καμία από τις κινήσεις δεν αλλάζει την σειρά των στοιχείων στην αριστερή ακολουθία, άρα τα στοιχεία θα γίνουν push με την σειρά που μας δίνονται.

**Παρατήρηση 2:** Δεν συμφέρει να κάνουμε δύο complement χωρίς να μεσολαβεί push.

*(Αιτιολόγηση)* Κάνουμε δύο κινήσεις που δεν επηρεάζουν κανένα στοιχείο που γίνεται push. Αφού ψάχνουμε τη μικρότερη ακολουθία , δεν μπορεί να υπάρχουν αυτές οι κινήσεις.

**Παρατήρηση 3:** Δεν συμφέρει να κάνουμε δύο reverse χωρίς να μεσολαβεί push.

*(Αιτιολόγηση)* Ξανά, κάνουμε δύο κινήσεις που δεν επηρεάζουν κανένα στοιχείο που γίνεται push.

**Παρατήρηση 4:** Η βέλτιστη ακολουθία κινήσεων δεν θα περιέχει ποτέ $$rcp$$.

*(Αιτιολόγηση)* Το reverse επηρεάζει την δεξιά ακολουθία ενώ το complement επηρεάζει την αριστερή. Άρα μπορούμε να τους αλλάξουμε θέση (δηλαδή κάνουμε $$crp$$ αντί για $$rcp$$) και να πάρουμε μία ακολουθία κινήσεων με την ίδια επίδραση και το ίδιο πλήθος, αλλά λεξικογραφικά μικρότερη.

Χρησιμοποιώντας αυτές τις παρατηρήσεις, μπορούμε να δούμε το πρόβλημα ως εξής: Μας δίνονται $$N$$ στοιχεία και για κάθε ένα επιλέγουμε μία από τις κινήσεις $$\lbrace p, rp, cp, crp \rbrace$$ ώστε στο τέλος να έχουμε μία δεξιά ακολουθία που τα στοιχεία είναι ομαδοποιημένα. Από όλες τις ακολουθίες κινήσεων, ψάχνουμε για την βέλτιστη (όπως την ορίσαμε προηγουμένως).

## Brute force λύση -- $$\mathcal{O}(4^N)$$

Η brute force λύση είναι να δοκιμάσουμε σε κάθε βήμα όλες τις δυνατές κινήσεις. Από τις ακολουθίες κινήσεων που θα οδηγήσουν σε ομαδοποιημένες δεξιές ακολουθίες κρατάμε την βέλτιστη. Κάνουμε μία κίνηση για κάθε στοιχείο και υπάρχουν το πολύ $$4$$ επιλογές. Άρα ο αλγόριθμος θέλει $$\mathcal{O}(4^N)$$ χρόνο, που είναι πολύ αργό για τα περισσότερα testcases.

## Λύση με δυναμικό προγραμματισμό -- $$\mathcal{O}(N^2)$$

**Παρατήρηση 5:** Για να ελέγξουμε αν μπορούμε να εισάγουμε ένα στοιχείο σε μία ομαδοποιημένη αριστερή ακολουθία, χρειάζεται να ξέρουμε μόνο:
 1. την σειρά που εμφανίζονται τα στοιχεία στην δεξιά ακολουθία
 2. αν τα στοιχεία στην αριστερή ακολουθία είναι αντεστραμμένα

Πιο συγκεκριμένα, το στοιχείο $$x_i$$ μπορεί να εισαχθεί μόνο αν:

 1. το δεξιότερο στοιχείο $$r = x_i$$ (ή $$r = 3 - x_i$$ αν τα στοιχεία της αριστερής ακολουθίας είναι αντεστραμμένα), ή
 2. δεν υπάρχει το στοιχείο $$x_i$$ στην δεξιά ακολουθία (ή το $$3 - x_i$$ αν τα στοιχεία της αριστερής ακολουθίας είναι αντεστραμμένα)

*(Αιτιολόγηση)* Ας δούμε την περίπτωση που δεν έχουμε αντιστροφή (η αντιστροφή έχει το ίδιο επιχείρημα με $$3-x_i$$ αντί για $$x_i$$). 
 1. Προφανώς αν το δεξιότερο στοιχείο είναι $$x_i$$, τότε μπορούμε απλά να το κάνουμε push χωρίς να αλλάξει η ομαδοποίηση. 
 2. Αν δεν υπάρχει το $$x_i$$, τότε δημιουργούμε για αυτό μία καινούργια ομάδα.

Αν δεν ισχύει καμία από τις δύο συνθήκες, τότε άμα το κάνουμε push, θα δημιουργηθεί μία δεύτερη ομαδοποίηση (πχ αν $$x_i = 2$$, τότε για $$1 1 2 2 3$$, κάνοντας push το $$2$$ δημιουργεί μία δεύτερη ομάδα για το $$2$$).


Επίσης, γνωρίζοντας αυτές τις δύο πληροφορίες, μπορούμε να κάνουμε complement και reverse. Ορίζουμε ως κατάσταση ``s = (positions, is_complemented)``, όπου ``positions[x]`` είναι η θέση της ομάδας του ``x`` (ή $$0$$ αν δεν εμφανίζεται) και ``is_complemented`` είναι η boolean που δείχνει αν τα στοιχεία στην αριστερή ακολουθία είναι αντεστραμμένα. Θα κάνουμε δυναμικό προγραμματισμό στο ``dp(i, s)``, που μας δίνει την βέλτιστη ακολουθία όταν επεξεργαζόμαστε το $$i$$-οστό στοιχείο και είμαστε στην κατάσταση ``s``. Χρησιμοποιούμε forward DP όπου οι μεταβάσεις είναι οι δυνατές κινήσεις $$\lbrace p, cp, crp, rp \rbrace$$ (σύμφωνα με τις παρατηρήσεις 1-4).

Στον κώδικα, για ευκολία, για κάθε κατάσταση ``s`` κρατάμε:
 * ένα πίνακα ``position`` με την σειρά των $$4$$ τιμών
 * τις αριστερότερες (``leftmost``) και δεξιότερες (``rightmost``) τιμές
 * το πλήθος ``count`` των διαφορετικών τιμών που έχουν εμφανιστεί
 * το ``is_complemented``, αν η αριστερή ακολουθία έχει γίνει complemented μονό αριθμών φορών.

Για παράδειγμα, για την εξής δεξιά ακολουθία

$$\underbrace{2\; 2 \; 2 \; 2}_{1} \; \; \; \underbrace{3\; 3 \; 3}_{2} \; \; \;\underbrace{0\; 0 \; 0 \; 0 \; 0}_{3}$$

το ``positions = [3, 0, 1, 2]``, το ``leftmost = 2``, το ``rightmost = 0``, ``count = 3`` και το ``is_complemented`` θα μπορούσε να είναι true ή false. Θα δούμε στην τέταρτη λύση, πώς μπορούμε να συμπιέσουμε αυτή την αναπαράσταση.

{% include code.md solution_name='pcr_slow.cc' start=10 end=57 %}

Κρατάμε μόνο τις δυνατές καταστάσεις για το $$i$$ και υπολογίζουμε τις δυνατές καταστάσεις για το $$i + 1$$. Για να μπορούμε να συγκρίνουμε γρήγορα, βάζουμε τις τιμές σε ένα map, όπου το κλειδί είναι η κατάσταση και η τιμή είναι η βέλτιστη ακολουθία κινήσεων που μας οδήγησε εκεί. Κρατάμε την ακολουθία κινήσεων σε μορφή string ώστε να μπορούμε να συγκρίνουμε εύκολα ποια είναι λεξικογραφικά μικρότερη. Αυτό κάνει τον αλγόριθμό μας πιο αργό (γιατί συγκρίνουμε και αντιγράφουμε strings μεγέθους $$O(N)$$). Θα δούμε στην τρίτη λύση πώς μπορούμε να το αποφύγουμε.


Πιο συγκεκριμένα, ορίζουμε ``map<State, string> current, next;`` που κρατάει τις δυνατές καταστάσεις στην θέση $$i$$ (και αντίστοιχα $$i+1$$) μαζί με την βέλτιση ακολουθία κινήσεων που οδήγησε σε αυτή. 

Για ευκολία ορίζουμε την ``compare_and_add`` για να συγκρίνει αν για την ίδια κατάσταση έχουμε βρει μία καλυτερη ακολουθία από την μέχρι στιγμής βέλτιστη:

{% include code.md solution_name='pcr_slow.cc' start=60 end=71 %}

Αυτό μας επιτρέπει να ορίσουμε τις μεταβάσεις ως εξής:

```c++
int current_val = state.is_complemented ? (3 - x[i]) : x[i];
```

 * Για την κίνηση $$p$$:

{% include code.md solution_name='pcr_slow.cc' start=89 end=94 %}

 * Για την κίνηση $$rp$$:

{% include code.md solution_name='pcr_slow.cc' start=96 end=101 %}

 * Για την κίνηση $$cp$$:

{% include code.md solution_name='pcr_slow.cc' start=104 end=110 %}

 * Για την κίνηση $$crp$$:

{% include code.md solution_name='pcr_slow.cc' start=113 end=119 %}

Επειδή υπάρχουν μόνο $$4$$ στοιχεία, το πλήθος των δυνατών ``positions`` είναι σταθερός αριθμός (για την ακρίβεια[^PositionCount] $$65$$), αρά υπάρχουν το πολύ οι διπλάσιες καταστάσεις (για complemented και όχι complemented). Οι δυνατές μεταβάσεις είναι $$4$$, και η σύγκριση μεταξύ ακολουθιών θέλει $$\mathcal{O}(N)$$ χρόνο, άρα ο αλγόριθμος θέλει συνολικά $$\mathcal{O}(N^2)$$ χρόνο, που είναι αρκετό για να περάσει περίπου το 50% των testcases. Θα βρείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='pcr_slow.cc' %}).

[^PositionCount]: Το πλήθος όλων των διατεταγμένων υποσυνόλων ενός συνόλου μεγέθους $$n$$ δίνεται από τον τύπο: 
   
    $$T(n) = \binom{n}{0} \cdot 0! + \binom{n}{1} \cdot 1! + \ldots + \binom{n}{n} \cdot n!$$
   
    Για $$n = 4$$, δίνει $$65$$ (δείτε περισσότερα [εδώ](http://www.hms.gr/sites/default/files/subsites/competitions/2012/SYNDYASTIKH_01.pdf) ή [εδώ](https://www.topcoder.com/community/competitive-programming/tutorials/basics-of-combinatorics/)).

## Γρηγορότερη εύρεση βέλτιστης ακολουθίας κινήσεων -- $$\mathcal{O}(N)$$

Το μεγαλύτερο πρόβλημα της προηγούμενης λύσης είναι η εύρεση της βέλτιστης ακολουθίας σε $$\mathcal{O}(N^2)$$. Τώρα, θα δούμε πώς μπορεί να γίνει πιο αποδοτικά.

Η ιδέα είναι να κρατάμε τις δυνατές καταστάσεις της στιγμής $$i$$ ταξινομημένες με την λεξικογραφική σειρά των βέλτιστων ακολουθιών κινήσεων για να φτάσουμε σε αυτές. Μετά, εξετάζουμε τις δυνατές κινήσεις για κάθε μία από αυτές με λεξικογραφική σειρά, δηλαδή $$\lbrace cp, crp, p, rp \rbrace$$. Όπως πριν για κάθε κατάσταση κρατάμε την μικρότερη ακολουθία, αλλά αν υπάρχουν δύο με ίσο μήκος, τότε κρατάμε αυτή που κοιτάξαμε πρώτη (γιατί είναι λεξικογραφικά μικρότερη). Τέλος, ταξινομούμε τις καταστάσεις του $$i+1$$, με βάση την σειρά των ακολουθιών κινήσεων που οδήγησαν σε αυτές. Η εικόνα παρακάτω δείχνει δύο πιθανές εκδοχές.

![](/assets/32-pdp-c-pcr-sorting-examples.svg){:width="520px"}

Οι μεταβάσεις αλλάζουν ως εξής:

{% include code.md solution_name='pcr_semi_efficient.cc' start=69 end=129 %}

Όπου η ``compare_and_add`` αλλάζει ως εξής:

```c++
void compare_and_add(
  map<State, tuple<int, long, long> >& next, vector<pair<int, long> >& par, State state, 
  long order_id, long length, long par_id, long operation_id) {
   if (next.find(state) == next.end() || std::get<2>(next[state]) > length) {
      next[state] = make_tuple(order_id, par.size(), length);
      par.push_back({operation_id, par_id});
   }
}
```

Κρατώντας για κάθε κατάσταση ``s`` την κατάσταση ``par[s]`` που οδήγησε στην βέλτιστη ακολουθία κινήσεων στο ``s``, μπορούμε να ανακτήσουμε την βέλτιστη ακολουθία, ακολουθώντας τους δείκτες ``par[s]``.

{% include code.md solution_name='pcr_semi_efficient.cc' start=131 end=151 %}

Η χρονική πολυπλοκότητα αυτού του αλγορίθμου είναι $$\mathcal{O}(N)$$, αλλά επειδή η σταθερά του $$N$$ είναι μεγάλη, η λύση παίρνει περίπου 70%. Θα βρείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='pcr_semi_efficient.cc' %}).

## Βέλτιστη λύση -- $$\mathcal{O}(N)$$

Η παραπάνω λύση αφιερώνει αρκετό χρόνο στη σύγκριση και δημιουργία καταστάσεων. Πιο συγκεκριμένα, κάθε ένα από τα ``positions``, ``leftmost``, ``rightmost`` και ``count``, κρατάνε έναν ακέραιο $$\leq 5$$. Άρα χρησιμοποιούμε μόνο $$21$$ bits από $$7$$ ακεραίους. Επειδή χρειαζόμαστε μόνο $$22$$ bits ($$21$$ συν ένα για το ``is_complemented``), μπορούμε να τα αποθηκεύσουμε όλα σε έναν ακέραιο $$32$$ bit. Διαλέγουμε την εξής αναπαράσταση (αλλά υπάρχουν πολλές παρόμοιες):

![](/assets/32-pdp-c-pcr-bit-representation-format.svg){:width="700px"}

Για το παράδειγμα

$$\underbrace{2\; 2 \; 2 \; 2}_{1} \; \; \; \underbrace{3\; 3 \; 3}_{2} \; \; \;\underbrace{0\; 0 \; 0 \; 0 \; 0}_{3}$$

η αναπαράσταση είναι η παρακάτω (όπου το $$x$$ αναπαριστά αν είναι complemented ή όχι η κατάσταση). Ας σημειωθεί ότι στην παρακάτω εικόνα έχουμε γράψει αριστερά τα λιγότερο σημαντικά ψηφία της δυαδικής αναπαράστασης, και δεξιά τα περισσότερο σημαντικά, οπότε με $$110$$ στο δυαδικό εννοούμε $$3$$ στο δεκαδικό (όχι $$6$$).

![](/assets/32-pdp-c-pcr-bit-representation-example.svg){:width="700px"}

Γι'αυτό θα χρειαστούμε κάποια bit tricks (μπορείτε να διαβάσετε περισσότερα [εδώ](https://www.topcoder.com/community/competitive-programming/tutorials/a-bit-of-fun-fun-with-bits/)). Πιο συγκεκριμένα, χρειαζόμαστε τα εξής:

 * Διάβασμα τριών bits από έναν ακέραιο (όπου ``_111 = 7``):

{% include code.md solution_name='pcr_efficient.cc' start=21 end=30 %} 
 
 * Αλλαγή τριών bits σε ένα ακέραιο:

{% include code.md solution_name='pcr_efficient.cc' start=32 end=41 %} 

 * Διάβασμα ενός bit:

{% include code.md solution_name='pcr_efficient.cc' start=55 end=55 %}

 * Αλλαγή ενός bit:
 
{% include code.md solution_name='pcr_efficient.cc' start=59 end=59 %}


Το μόνο που χρειάζεται να αλλάξουμε από την προηγούμενη λύση είναι το ``State``:

{% include code.md solution_name='pcr_efficient.cc' start=17 end=108 %}

Υπάρχουν και άλλες βελτιστοποιήσεις που θα μπορούσαν να γίνουν, αλλά αυτή είναι αρκετή ώστε ο κώδικας περάσει όλα τα testcases. Θα βρείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='pcr_efficient.cc' %}).
