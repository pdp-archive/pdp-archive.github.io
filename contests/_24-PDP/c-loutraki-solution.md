---
layout: solution
codename: loutraki
---

## Επεξήγηση εκφώνησης


Μας δίνεται ένας πίνακας με $$N$$ σημεία και μας ζητείται να υπολογίσουμε **πόσα από τα σημεία δεν κρύβονται ούτε από την αριστερή τους πλευρά αλλά ούτε και από την κάτω τους πλευρά**. Για την καλύτερη κατανόηση λόγο της ύπαρξης τόσο θετικών όσο και αρνητικών τιμών στις συντεταγμένες δείτε το παρακάτω σχεδιάγραμμα  

![Παράδειγμα](/assets/24-pdp-c-loutraki-example2.png){:width="640px"}

Στο παραπάνω παράδειγμα, μόνο τα πράσινα ξενοδοχεία θεωρούνται προνομιούχα. Πιο αναλυτικά:  
&nbsp;&nbsp;Το ξενοδοχείο 1 δεν κρύβεται από κανένα άλλο.  
&nbsp;&nbsp;Το ξενοδοχείο 2 κρύβεται από τα 3,6,8.  
&nbsp;&nbsp;Το ξενοδοχείο 3 κρύβεται από τα 1,6,8.  
&nbsp;&nbsp;Το ξενοδοχείο 4 κρύβεται από τα 3,1,7.  
&nbsp;&nbsp;Το ξενοδοχείο 5 δεν κρύβεται από κανένα άλλο.  
&nbsp;&nbsp;Το ξενοδοχείο 6 κρύβεται από τα 5 και 8.  
&nbsp;&nbsp;Το ξενοδοχείο 7 κρύβεται από τα 5 και 6.  
&nbsp;&nbsp;Το ξενοδοχείο 8 δεν κρύβεται από κανένα άλλο.  
  
  	
  	
## Αργή λύση $$\mathcal{O}(N^2)$$

Δοκιμάζουμε για κάθε ένα από τα $$N$$ ξενοδοχεία όλους τους $$N-1$$ συνδυασμούς για να βρούμε αν κρύβεται από κάποιο άλλο. Συνολική πολυπλοκότητα $$\mathcal{O}(N^2)$$ .

Παρακάτω δίνεται μία ενδεικτική υλοποίηση αυτής της λύσης.

{% include code.md solution_name='loutraki_n2.cc' %}

## Mέτρια λύση - $$\mathcal{O}(N \cdot log(N))$$ - line sweep

Γνώσεις που θα χρειαστούμε: lambda functions (c++11 και νεότερες)

Ταξινομούμε τα ξενοδοχεία πρώτα ως προς $$x$$ και μετά ως προς $$y$$ στον πίνακα $$C[]$$.
Σαρώνουμε από τις μικρότερες προς τις μεγαλύτερες ώστε να ενημερώσουμε τον πίνακα των ξενοδοχείων για το αν έχουν ορατότητα από αυτή την πλευρά.
Αξιοποιούμε το πρώτο στοιχείο που συναντούμε και πετάμε τα υπόλοιπα με την ίδια τιμή στη συντεταγμένη $$x$$.
Το ίδιο θα κάνουμε και για το $$y$$.  

Η ταξινόμηση γίνεται με χρήση δικών μας συναρτήσεων σύγκρισης. Προτιμήθηκε η λύση της lambda (inline σύντομες συναρτήσεις) για να δειχθεί αυτή η λειτουργία της c++.

{% include code.md solution_name='loutraki_nlogn_sweep.cc' start=35 end=35 %}

Στην παραπάνω εντολή ταξινομούμε τον πίνακα $$C[]$$ πρώτα με το $$x$$ και σε περίπτωση ισότητας με το $$y$$.
Η συνάρτηση:
```c++
[](const auto& a,const auto& b){return (a.x==b.x)?(a.y<b.y):(a.x<b.x);}
```
λέγεται lambda συνάρτηση και είναι η συνάρτηση σύγκρισης που θα χρησιμοποιήσει η sort. Μέσα στα άγκιστρα αυτό που κάνει είναι απλά να συγκρίνει τις συντεταγμένες δυο αντικειμένων του πίνακα, των $$a$$ και $$b$$. Μέσα στις $$[]$$ πρέπει να δηλώσουμε αν και πως η lambda μας θα έχει πρόσβαση σε άλλες μεταβλητές του προγράμματος εκτός από αυτές που παίρνει ως παραμέτρους. Η συγκεκριμένη lambda δεν χρειάζεται τίποτα άλλο από τα δυο στοιχεία του πίνακα οπότε παραμένει κενό το τμήμα αυτό.  

Η λύση αυτή περνά τα 12 από τα 15 test cases.

{% include code.md solution_name='loutraki_nlogn_sweep.cc' %}  
  
## Μέτρια λύση - $$\mathcal{O}(N \cdot log(N))$$

Γνώσεις που θα χρειαστούμε: std::vector, std::sort ([C++ stl](https://kallinikos.github.io/STL))

Η λύση που θα δούμε εισάγει ιδέες που θα χρειαστούν για την βέλτιστη λύση.

Αποθηκεύουμε για κάθε διακριτή συντεταγμένη όλες τις αντίστοιχες συντεταγμένες του άλλου άξονα. Θα ελέγξουμε το κάθε ένα από τα $$N$$ ξενοδοχεία, αν επικαλύπτεται από κάποιο άλλο σε πολυπλοκότητα $$\mathcal{O}(logN)$$.

Η λύση αυτή περνά τα 12 από τα 15 test cases.

Μία ενδεικτική υλοποίηση παρουσιάζεται παρακάτω:

{% include code.md solution_name='loutraki_nlogn_2.cc' %}

## Παρατήρηση  
Σε κάθε διακριτή τιμή τετμημένης($$x$$) ή τεταγμένης($$y$$) μας ενδιαφέρει μόνο **το ξενοδοχείο με την μικρότερη τεταγμένη ή τετμημένη** αντίστοιχα γι' αυτό και στην προηγούμενη λύση χρησιμοποιούσαμε μόνο το πρώτο στοιχείο του __vector__. Δηλαδή από όλα τα ξενοδοχεία με ίδιο $$x$$ μας ενδιαφέρει μόνο το ξενοδοχείο με το μικρότερο $$y$$.
Οπότε είμαστε έτοιμοι για την λύση με γραμμική πολυπλοκότητα που ακολουθεί.



## Βέλτιστη λύση - $$\mathcal{O}(N)$$

Επεξεργαζόμαστε κάθε ξενοδοχείό με τη σειρά που το διαβάζουμε από το αρχείο. Το υπο εξέταση ξενοδοχείο θα το ελέγξουμε ξεχωριστά για την κάθε συντεταγμένη. 

Κρατάμε στη θέση $$X[x]$$ του πίνακα $$X[]$$ τον αριθμό του ξενοδοχείου $$(x,y)$$ με τη μικρότερη τεταγμένη $$y$$.
Αντίστοιχα κρατάμε και στη θέση $$Y[y]$$ του πίνακα $$Y[]$$ τον αριθμό του ξενοδοχείου $$(x,y)$$ με τη μικρότερη τετμημένη $$x$$.

Αν δεν υπάρχει κανένα ξενοδοχείο με το ίδιο $$x$$ τότε δεν το κρύβει κανένα άλλο από το να "βλέπει" προς τα κάτω οπότε αυτό αποκτά ορατότητα από την πλευρά αυτή.
Αν υπάρχει ξενοδοχείο με το ίδιο $$x$$ τότε υπάρχουν δυο περιπτώσεις, ή το υπο εξέταση ξενοδοχείο κρύβεται από το ξενοδοχείο $$X[x]$$ ή θα κρύψει το παλιότερο ξενοδοχείο $$X[x]$$. 

Στην περίπτωση που κρυφτεί το παλιό ξενοδοχείο πρέπει να δώσουμε προσοχή στο αν πρέπει να διορθώσουμε την μεταβλητή $$\mathit{ans}$$. Αν το παλιό ξενοδοχείο είχε επηρεάσει την μεταβλητή $$\mathit{ans}$$ τότε πρέπει να την μειώσουμε, πράγμα που κάνει το παρακάτω απόσπασμα κώδικα:  

{% include code.md solution_name='loutraki_n.cc' start=15 end=20 %}

**Μια σημείωση**: θα μπορούσαμε να μην κάνουμε διορθώσεις στη μεταβλητή $$\mathit{ans}$$ καθώς επεξεργαζόμαστε τα ξενοδοχεία και απλά στο τέλος του προγράμματος να κάνουμε ένα βρόγχο επανάληψης και να καταμετρήσουμε πόσα flags είναι σβηστά στον πίνακα $$\mathit{hidden[]}$$ και να τυπώσουμε αυτόν τον αριθμό.

Αφού κάνουμε τον ίδιο έλεγχο και για την τεταγμένη $$y$$ έχουμε μετρήσει από πόσες πλευρές έχει ορατότητα το ξενοδοχείο μας. Αν είναι $$visibility == 2$$ τότε το ξενοδοχείο μας είναι προνομιούχο τουλάχιστο μέχρι αυτή τη στιγμή.

**Πολυπλοκότητα:**  Η εξέταση κάθε ξενοδοχείου γίνεται μόνο μια φορά και ο υπολογισμός αν κρύβεται ή κρύβει γίνεται σε $$\mathcal{O}(1)$$ άρα η συνολική μας πολυπλοκότητα είναι $$\mathcal{O}(N)$$.

Μία ενδεικτική υλοποίηση παρουσιάζεται παρακάτω:

{% include code.md solution_name='loutraki_n.cc' %}  
  
## Γενική Παρατήρηση στις διαστάσεις των πινάκων

Στον πίνακα $$\mathit{hotel[ ]}$$ χρησιμοποιούμε τα στοιχεία $$1$$ έως και $$N$$ άρα πρέπει να έχει μέγεθος $$10^6+1$$.
Στους πίνακες $$X[ ]$$ και $$Y[ ]$$ θέλουμε να αποθηκεύουμε τιμές από $$-10^5$$ έως και $$+10^5$$ οι οποίες είναι $$10^5$$ από κάθε κατεύθυνση του άξονα συντεταγμένων και μια ακόμα τιμή που είναι το $$0$$ οπότε $$2\cdot 10^5 + 1$$ τιμές συνολικά.  
Λόγω του ότι είναι εύκολο να γίνει λάθος που θα παράγει σφάλμα κατάτμησης (segmentation fault) είναι προτιμότερο στους διαγωνισμούς να δεσμεύονται μερικά στοιχεία περισσότερο στους πίνακες (π.χ. 5 στοιχεία παραπάνω από ότι υπολογίζουμε ότι χρειάζεται) και ας μην χρησιμοποιηθούν, παρά να χαθούν test cases από τέτοιες λεπτομέρειες.   

{% include code.md solution_name='loutraki_n.cc' start=5 end=10 %}