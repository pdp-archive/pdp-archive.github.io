---
layout: solution
codename: smalltank
---

## Επεξήγηση εκφώνησης

Μας δίνεται ένας μη-κατευθυνόμενος γράφος $$G$$ με $$V$$ κορυφές και $$E$$ ακμές με βάρη. Μας ζητείται να βρούμε το ελάχιστο βάρος $$w^\star$$ ώστε να μπορούμε να πάμε από κάθε κορυφή $$u$$ σε κάθε άλλη $$v$$, διασχίζοντας μόνο ακμές $$e$$ με βάρος $$w(e) \leq w^\star$$.

Ακολουθεί η βασική παρατήρηση που θα χρησιμοποιήσουμε σε όλες τις παρακάτω λύσεις.

**Παρατήρηση:** Μπορούμε να πάμε από κάθε κορυφή $$u$$ σε κάθε άλλη $$v$$, διασχίζοντας μόνο ακμές $$e$$ με βάρος $$w(e) \leq w$$, αν και μόνο αν αφαιρώντας τις ακμές $$e$$ με βάρος $$w(e) > w$$, ο γράφος είναι συνδεδεμένος. 

Για παράδειγμα, στον παρακάτω γράφο αν αφαιρέσουμε τις ακμές με βάρος $$> 8$$, ο γράφος είναι συνδεδεμένος, άρα υπάρχει τρόπος να πάμε από κάθε ακμή σε κάθε άλλη με βάρη $$\leq 8$$. Αν αφαιρέσουμε τις ακμές με βάρος $$> 5$$, τότε ο γράφος δεν είναι συνδεδεμένος άρα δεν μπορούμε να πάμε από κάθε ακμή σε κάθε άλλη με βάρη $$\leq 5$$.

<center>
<img alt="Παραδείγματα συνδεδεμένου και μη-συνδεδεμένου γράφου" src="/assets/34-blyk-pdp-smalltank-examples.svg" width="500px">
</center>

Ακολουθούν οι εξής λύσεις:
 1. Brute force λύση: υλοποίηση της βασικής παρατήρησης
 1. Λύση με δυαδική αναζήτηση: επιτάγχυνση της brute force λύσης (100%)
 1. Λύση με disjoint sets: επιτάγχυνση της brute force λύσης (100%)
 1. Αλγόριθμος Camerini: λύση με βέλτιστη πολυπλοκότητα (100%)

## Brute force λύση

Η πρώτη λύση είναι να κάνουμε ακριβώς αυτό που λέει η βασική παρατήρηση: για κάθε $$w$$ να αφαιρέσουμε τις ακμές με βάρος $$>w$$ και να ελέγξουμε αν ο γράφος είναι συνδεδεμένος.

Ένας τρόπος να ελέγξουμε αν ο γράφος είναι συνδεδεμένος είναι κάνοντας αναζήτηση κατά βάθος (DFS). Ο τρόπος που δουλεύει η μη-αναδρομική DFS είναι διατηρώντας μία στοίβα $$\textit{st}$$ και για κάθε κορυφή $$v$$ το $$visit[v]$$, που μας λέει αν έχουμε επισκεφθεί την κορυφή $$v$$. Ξεκινάμε με την στοίβα να έχει μία οποιοδήποτε κορυφή. Έπειτα όσο η στοίβα δεν είναι άδεια, αφαιρεί την πάνω πάνω κορυφή και (αν δεν την έχουμε επισκεφθεί) προσθέτει τους γείτονές της στη στοίβα. 

Ο παρακάτω κώδικας κάνει αυτό:

{% include code.md solution_name='smalltank_brute_force.cc' start=12 end=34 %}

Έπειτα στο κυρίως τμήμα προσθέτουμε μία μία τις ακμές σε αύξουσα σειρά στον γράφο και ελέγχουμε αν ο γράφος είναι συνδεδεμένος:

{% include code.md solution_name='smalltank_brute_force.cc' start=50 end=62 %}

Ο έλεγχος για το αν ο γράφος είναι συνδεδεμένος θέλει $$\mathcal{O}(E + V)$$ χρόνο και χρειάζεται να τον κάνουμε το πολύ μία φορά για κάθε ακμή. Άρα συνολικά ο αλγόριθμος χρειάζεται $$\mathcal{O}(E \cdot (V + E))$$ χρόνο. Αυτό είναι αρκετό για να περάσει περίπου 14-16 από τα 21 testcases. 

Ακολουθεί ολόκληρος ο κώδικας για αυτή τη λύση:

{% include code.md solution_name='smalltank_brute_force.cc' %}

## Λύση με δυαδική αναζήτηση

Στην προηγούμενη λύση, αν παρατηρήσουμε τις απαντήσεις για τις κλήσεις στην συνάρτηση `is_connected`, που γίνεται με αύξουσα σειρά στα βάρη, θα δούμε ότι οι απαντήσεις είναι `false, false, false, ... , false, true, true, ..., true`. Στο παραπάνω παράδειγμα, οι απαντήσεις είναι οι εξής:

<center>
<img alt="Πώς αλλάζει ο γράφος από μη-συνδεδεμένος σε συνδεδεμένος όταν προσθέτουμε μία μία τις ακμές σε αύξουσα σειρά." src="/assets/34-blyk-pdp-smalltank-sequence.svg" width="700px">
</center>

Εμείς θέλουμε να βρούμε το πρώτο σημείο που η συνάρτηση επιστρέφει `true`. Επομένως μπορούμε να χρησιμοποιήσουμε δυαδική αναζήτηση:

{% include code.md solution_name='smalltank_binary_search.cc' start=50 end=66 %}

Η δυαδική αναζήτηση θέλει $$\mathcal{O}(\log E) = \mathcal{O}(\log V)$$ βήματα και κάθε ένα από αυτά τα βήματα θέλει $$\mathcal{O}(E + V)$$ χρόνο. Επομένως, συνολικά θέλει $$\mathcal{O}((V+E) \cdot \log V)$$ χρόνο, που είναι αρκετό για να περάσει όλα τα testcases. Μπορείτε να βρείτε [εδώ]({% include link_to_source.md solution_name='smalltank_binary_search.cc' %}) ολόκληρο τον κώδικα.

## Λύση με disjoint sets

*Η λύση αυτή απαιτεί γνώσεις για disjoint sets. Μπορείτε να μάθετε περισσότερα [εδώ](https://kallinikos.github.io/Union-Find-Disjoint-Sets) ή [εδώ](https://cp-algorithms.com/data_structures/disjoint_set_union.html).*

Η δομή δεδομένων disjoint sets, μας επιτρέπει να διατηρήσουμε σύνολα κορυφών και να ενώσουμε (`merge`) ή να ελέγξουμε αν είναι ενωμένα (με την `find_parent`) σε amortised χρόνο $$\mathcal{O}(\log V)$$[^Ackermann]. Η υλοποίηση είναι η ακόλουθη. 

[^Ackermann]: Ο χρόνος είναι ακόμα καλύτερος, είναι $$\mathcal{O}(\alpha(V, E))$$, όπου $$\alpha$$ είναι η αντίστροφη συνάρτηση Ackermann, που παίρνει πολύ μικρές τιμές (δείτε πχ [εδώ](https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity)). Σε αυτή την περίπτωση, λόγω της ταξινόμησης δεν χρειάζόμαστε κάτι καλύτερο από $$\mathcal{O}(\log V)$$.

{% include code.md solution_name='smalltank_disjoint_sets.cc' start=8 end=41 %}

Ο κυρίως κώδικας παραμένει παρόμοιος:

{% include code.md solution_name='smalltank_disjoint_sets.cc' start=56 end=67 %}

Ο αλγόριθμος χρειάζεται $$\mathcal{O}(E \cdot \log V)$$ χρόνο για την ταξινόμηση και $$\mathcal{O}(E \cdot \log V)$$ συνολικά για τις ενώσεις. Η λύση αυτή περνάει όλα τα testcases. Μπορείτε να βρείτε [εδώ]({% include link_to_source.md solution_name='smalltank_disjoint_sets.cc' %}) ολόκληρο τον κώδικα.

**Θεωρητική σημείωση:** Ο αλγόριθμος αυτός είναι ίδιος με αυτόν του Kruskal για την εύρεση του ελάχιστου συνδετικού δένδρου (minimum spanning tree (mst)). Ισχύει ότι η απάντηση σε αυτό το πρόβλημα είναι η βαρύτερη ακμή σε ένα (οποιοδήποτε) mst. Επομένως θα μπορούσαμε να χρησιμοποιήσουμε οποιονδήποτε άλλον αλγόριθμο για την εύρεση του mst (πχ του Prim). 

## Γραμμικός αλγόριθμος

Το πρόβλημα αυτό έχει την ονομασία [minimum bottleneck spanning tree](https://en.wikipedia.org/wiki/Minimum_bottleneck_spanning_tree) και υπάρχει αλγορίθμος, γνωστός ως αλγόριθμος του Camerini, ο οποίος λύνει το πρόβλημα σε $$\mathcal{O}(E)$$ χρόνο. Για τον διαγωνισμό, οι προηγούμενες λύσεις είναι εξίσου (ή και περισσότερο) αποδοτικές. Για όποιους ενδιαφέρονται, αναφέρουμε τα βήματα του αλγορίθμου:

Ο αλγόριθμος στηρίζεται ότι μπορούμε να βρούμε το μεσαίο όρο μίας ακολουθίας από $$N$$ όρους σε $$\mathcal{O}(N)$$ χρόνο. Ξεκινάμε βρίσκοντας την μεσαίου βάρους $$w_m$$ ακμή. Προσθέτουμε όλες τις $$E/2$$ ακμές με βάρος μικρότερο ή ίσο από αυτήν στον γράφο (σε $$\mathcal{O}(E)$$ χρόνο). Αν ο γράφος είναι συνδεδεμένος ξέρουμε ότι η απάντηση είναι στις $$E/2$$ μικρότερες, όποτε συνεχίζουμε αναδρομικά. Αν ο γράφος δεν είναι συνδεδεμένος, η απάντηση είναι στις $$E/2$$ μεγαλύτερες, οπότε ενώνουμε τις κορυφές συνδεδεμένες με τις $$E/2$$ μικρότερες ακμές και συνεχίζουμε αναδρομικά. Στις επόμενες αναδρομές θα έχουμε το πολύ $$E/4$$ ακμές, μετά $$E/8$$, κ.ο.κ.

Αν υλοποιήσουμε με προσοχή το κάθε βήμα ώστε να θέλει χρόνο γραμμικό προς το πλήθος των ακμών στον γράφο, τότε η συνολική πολυπλοκότητα είναι $$\mathcal{O}(E + E/2 + E/4 + E/8 + \ldots + 1) = \mathcal{O}(E)$$ [^GeomSum]. Μπορείτε να βρείτε [εδώ]({% include link_to_source.md solution_name='smalltank_linear.cc' %}) ολόκληρο τον κώδικα.

[^GeomSum]: $$E + E/2 + E/4 + \ldots + 1 \leq E + E/2 + E/4 + \ldots = E \cdot (1 + 1/2 + 1/4 + 1/8 + \ldots) = 2 \cdot E$$ ως το άθροισμα άπειρης γεωμετρικής προόδου με λόγο $$1/2$$.