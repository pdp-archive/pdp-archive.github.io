---
layout: solution
codename: supermarket
---

## Επεξήγηση εκφώνησης

Για να μεγιστοποιήσουμε την συνολική αξία των δωροεπιταγών, πρέπει ουσιαστικά να μεγιστοποιήσουμε το άθροισμα της αξίας των προϊόντων στις θέσεις που είναι πολλαπλάσια του $$K$$. Ας πάρουμε το πρώτο παράδειγμα από την εκφώνηση.

```plaintext
5 1 2
10 2 6 4 8
```

Άρα έχουμε στη διάθεσή μας $$1$$ μετακίνηση και τα πολλαπλάσια του $$2$$ είναι οι θέσεις των δωροεπιταγών. Στην παρακάτω εικόνα οι θέσεις αυτές παριστάνονται με πράσινο χρώμα.

{: .center_image}
![Παράδειγμα 1](/assets/27-pdp-c-supermarket-example-1-start.svg "Παράδειγμα 1"){:width="300px"}

Αν δεν κάνουμε καμία μετακίνηση η συνολική αξία θα είναι $$2 + 4 = 6$$. Αν όμως μετακινήσουμε το πρώτο (ή και το δεύτερο) στοιχείο, τότε αυξάνουμε τη συνολική αξία σε $$6 + 8 = 14$$.

{: .center_image}
![Παράδειγμα 1 αλλαγή αντικειμένου](/assets/27-pdp-c-supermarket-example-1-transition.svg "Παράδειγμα 1 αλλαγή αντικειμένου"){:width="700px"}

## Λύση με brute force

Η πιο απλή λύση είναι να δοκιμάσουμε όλους τους πιθανούς τρόπους να μετακινήσουμε $$M$$ αντικείμενα. Ξεκινώντας από την αρχή της λίστας και πηγαίνοντας προς το τέλος, κάθε αντικείμενο μπορούμε είτε να το μετακινήσουμε είτε να το αφήσουμε στη θέση του, με μόνο περιορισμό να μην μετακινήσουμε πάνω από $$M$$ αντικείμενα συνολικά.

Μπορούμε να κρατάμε ποια αντικείμενα έχουμε μετακινήσει σε ένα πίνακα $$\mathit{moved}[i]$$, όπου $$\mathit{moved}[i] = \mathit{false}$$ αν δεν μετακινήσαμε το αντικείμενο και $$\mathit{moved}[i] = \mathit{true}$$ αν το μετακινήσαμε στο τέλος του ιμάντα. Σε κώδικα μπορούμε να το γράψουμε κάπως έτσι:

{% include code.md solution_name='supermarket_brute_force.cc' start=36 end=53 %}

Η συνάρτηση $$\mathit{calculate_total_score}$$ πρέπει να υπολογίσει την τελική θέση κάθε αντικειμένου και να προσθέσει την αξία του αν η θέση είναι πολλαπλάσιο του $$K$$.

**Παρατήρηση 1:** Έστω ότι έχουμε μετακινήσει $$k$$ από τα $$i - 1$$ πρώτα αντικείμενα. Τότε αν δεν μετακινήσουμε το $$i$$-οστό αντικείμενο, στην τελική διάταξη θα βρίσκεται στην θέση $$i-k$$.

**Παρατήρηση 2:** Έστω ότι έχουμε μετακινήσει $$k - 1$$ από τα $$i - 1$$ πρώτα αντικείμενα και συνολικά μετακινήσαμε $$m$$. Τότε αν μετακινήσουμε το $$i$$-οστό αντικείμενο, στην τελική διάταξη θα βρίσκεται στην θέση $$N - m + k$$.

{% include code.md solution_name='supermarket_brute_force.cc' start=12 end=34 %}

Το μόνο που μας μένει είναι να καλέσουμε την συνάρτηση $$\mathit{iterate(1, 0)}$$.

Η πολυπλοκότητα της λύσης είναι $$\mathcal{O}(2^N)$$, αφού για κάθε στοιχείο έχουμε δύο επιλογές, είτε να το μετακινήσουμε είτε όχι.

> Πιο συγκεκριμένα, η πολυπλοκότητα είναι όσος ο αριθμός των επιλογών που μπορούμε να κάνουμε, που είναι ο αριθμός των τρόπων με τους οποίους μπορούμε να διαλέξουμε $$m$$ αντικείμενα από τα $$N$$ με $$0 \leq m \leq M$$. Αυτό μπορεί να γραφτεί ώς $$\mathit{total\_states}(N, M) = \sum_{m=0}^M{\binom{N}{m}}$$. Για $$M = N$$, $$\mathit{total\_states}(N, N) = \mathcal{O}(2^N)$$, και για τιμές του $$M$$ κοντά στο $$N$$ δεν έχουν μεγάλη διαφορά οι πολυπλοκότητες, αλλά για μικρές τιμές του $$M$$ σε σχέση με το $$N$$, η πολυπλοκότητα μπορεί να είναι σημαντικά μικρότερη.

Δείτε ολοκληρωμένη τη λύση [εδώ]({% include link_to_source.md solution_name='supermarket_brute_force.cc' %}).

## Λύση με δυναμικό προγραμματισμό

**Παρατήρηση 1:** Για να υπολογίσουμε την τελική θέση ενός προϊόντος, όπως είδαμε στην προηγούμενη λύση χρειάζεται να ξέρουμε την αρχική του θέση, πόσα αντικείμενα από αυτά που έχουν προηγηθεί έχουν μετακινηθεί και πόσα αντικείμενα έχουν μετακινηθεί συνολικά (το τελευταίο το χρειαζόμαστε για την θέση των αντικειμένων που έχουν μετακινηθεί).

**Παρατήρηση 2:** Αν γνωρίζουμε τον συνολικό αριθμό των μετακινήσεων που θα γίνουν, και έχουμε λύσει το πρόβλημα για τα πρώτα $$i$$ αντικείμενα (έχοντας ίσως μετακινήσει κάποια απο αυτά), τότε η συνολική λύση είναι ανεξάρτητη από το ποια αντικείμενα έχουν μετακινηθεί, και εξαρτάται μόνο από το πόσα αντικείμενα έχουν μετακινηθεί από τα πρώτα $$i$$.

<details markdown="1">
  <summary>Σχηματικό παράδειγμα</summary>
Ας το δούμε και σχηματικά. Έχουμε $$N$$ αντικείμενα και από τα πρώτα $$i$$ (μπλε χρώμα) μετακινούμε $$m_1$$ αντικείμενα και από τα υπόλοιπα $$N - i$$ (κόκκινο χρώμα) μετακινούμε $$m_2$$ ($$m_1 + m_2 \leq M$$). Παρατηρούμε ότι τα δύο σύνολα αντικειμένων πάντα καταλαμβάνουν τις ίδιες θέσεις ανεξάρτητα από το ποια αντικείμενα επιλέγουμε να μετακινήσουμε. Άρα μπορούμε να μεγιστοποιήσουμε την αξία του κάθε συνόλου ξεχωριστά για να βρούμε την συνολική βέλτιστη λύση (για τα δεδομένα $$m_1$$ και $$m_2$$ και $$i$$).

{: .center_image}
![Παράδειγμα 2](/assets/27-pdp-c-supermarket-example-2.svg "Παράδειγμα 2"){:width="700px"}

Ας πάρουμε το αρχικό παράδειγμα με $$N=5$$, $$M=2$$, $$K=3$$ και $$i=3$$, $$m_1=1$$, $$m_2=1$$. Η αρχική του κατάσταση είναι επομένως η παρακάτω ($$i=3$$, οπότε τα πρώτα $$3$$ στοιχεία είναι μπλε).

{: .center_image}
![Παράδειγμα 3 αρχική θέση](/assets/27-pdp-c-supermarket-example-3-start.svg "Παράδειγμα 3 αρχική θέση"){:width="300px"}

Οι πιθανές εναλλακτικές για τα μπλε είναι οι παρακάτω. Βλέπουμε ότι όποια αλλαγή και να κάνουμε στα μπλε, τα κόκκινα παραμένουν στις ίδιες θέσεις.

{: .center_image}
![Παράδειγμα 3 εναλλακτικές](/assets/27-pdp-c-supermarket-example-3-options.svg "Παράδειγμα 3 εναλλακτικές"){:width="300px"}
</details>

Χρησιμοποιώντας αυτές τις παρατηρήσεις μπορούμε να ορίσουμε την συνάρτηση $$\mathit{dp}(i, \mathit{current\_moves}, \mathit{total\_moves})$$, η οποία μας δίνει την βέλτιστη λύση για τα πρώτα $$i$$ αντικείμενα αν έχουμε κάνει $$\mathit{current\_moves}$$ μετακινήσεις στα πρώτα $$i$$ αντικείμενα και συνολικά θα κάνουμε $$\mathit{total\_moves}$$ μετακινήσεις.

Το επόμενο βήμα είναι να υπολογίσουμε τις τιμές της συνάρτησης $$\mathit{dp}$$. Μπορούμε να πάρουμε την τιμή του $$\mathit{dp}(i, \mathit{current\_moves}, \mathit{total\_moves})$$ επαγωγικά. Έχουμε $$2$$ επιλογές για το $$i$$-οστό αντικείμενο, είτε το μετακινούμε είτε όχι.

* Αν μετακινήσουμε το $$i$$-οστό αντικείμενο, τότε μέχρι το $$i - 1$$ έχουμε μετακινήσει $$\mathit{current\_moves - 1}$$ αντικείμενα. Όπως είδαμε στην αρχική λύση, η τελική θέση του αντικειμένου σε αυτή τη περίπτωση είναι $$N - \mathit{total\_moves} + \mathit{current\_moves}$$. Άρα τότε έχουμε

$$
\mathit{dp}(i, \mathit{current\_moves}, \mathit{total\_moves}) = \mathit{dp}(i - 1, \mathit{current\_moves - 1}, \mathit{total\_moves}) + \\
\mathit{items}[i] \cdot is\_multiple\_of\_K(N - \mathit{total\_moves} + \mathit{current\_moves})
$$

* Αν δεν μετακινήσουμε το $$i$$-οστό αντικείμενο, τότε μέχρι το $$i - 1$$ έχουμε μετακινήσει $$\mathit{current\_moves}$$ αντικείμενα. Όπως είδαμε στην αρχική λύση, η τελική θέση του αντικειμένου σε αυτή τη περίπτωση είναι $$i - \mathit{current\_moves}$$. Άρα τότε έχουμε

$$
\mathit{dp}(i, \mathit{current\_moves}, \mathit{total\_moves}) = \mathit{dp}(i - 1, \mathit{current\_moves}, \mathit{total\_moves}) + \\
\mathit{items}[i] \cdot is\_multiple\_of\_K(i - \mathit{current\_moves})
$$

Καθώς θέλουμε τη βέλτιστη λύση για το $$\mathit{dp}(i, \mathit{current\_moves}, \mathit{total\_moves})$$, η τελική τιμή είναι η μέγιστη από τις δύο παραπάνω, εφόσον τηρούνται οι απαραίτητες συνθήκες ($$\mathit{current\_moves} \leq i$$ **και** $$\mathit{current\_moves} \leq \mathit{total\_moves} \leq N$$).

Η τελική βέλτιστη λύση είναι η μέγιστη από τα $$\mathit{dp}(N, \mathit{total\_moves}, \mathit{total\_moves})$$ για κάθε $$\mathit{total\_moves} = 0, \ldots, M$$.

Καθώς το $$\mathit{total\_moves}$$ μένει σταθερό, κατά την επαγωγή μπορούμε να απλοποιήσουμε την συνάρτηση σε $$\mathit{dp}(i, \mathit{current\_moves})$$ και να την υπολογίσουμε για κάθε τιμή του $$\mathit{total\_moves}$$. Επίσης μπορούμε να αποθηκεύουμε τις τιμές της συνάρτησης σε έναν πίνακα `dp[i][current_moves]` με διαστάσεις $$N \times M$$.

{% include code.md solution_name='supermarket_dp.cc' start=34 end=67 %}

Κάθε υπολογισμός του πίνακα dp θέλει $$\mathcal{O}(N \cdot M)$$ χρόνο. Αφού έχουμε $$\mathcal{O}(M)$$ επαναλήψεις, η συνολική πολυπλοκοτητα του αλγορίθμου είναι $$\mathcal{O}(N \cdot M^2)$$.

Δείτε ολόκληρη τη λύση [εδώ]({% include link_to_source.md solution_name='supermarket_dp.cc' %}).

Παρατηρώντας ότι σε κάθε επανάληψη του $$i$$ χρησιμοποιούμε μόνο τιμές της μορφής $$\mathit{dp}[i-1][\cdot]$$, μπορούμε να μειώσουμε την μνήμη σε $$\mathcal{O}(M)$$ (δείτε τον κώδικα [εδώ]({% include link_to_source.md solution_name='supermarket_dp_mem.cc' %})).
