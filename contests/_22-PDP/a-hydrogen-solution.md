---
layout: solution
codename: hydrogen
---

## Λύση με Bubble Sort

Πρέπει να ταξινομήσουμε τους αριθμούς των τμημάτων των αυτοκινήτων που παρουσίασαν βλάβη από ευθύνη του κατασκευαστή σε φθίνουσα σειρά με βάση τη συχνότητα εμφάνισης τέτοιας βλάβης και σε αύξουσα με βάση τον αριθμό τμήματος αυτοκινήτου σε περίπτωση ίσων συχνοτήτων.

Για διευκόλυνσή μας μπορούμε να ορίσουμε ένα struct, έστω car_part, το οποίο θα περιέχει τον αριθμό ενός τμήματος του αυτοκινήτου και τη συχνότητα εμφάνισης βλαβών υπευθυνότητας του κατασκευαστή σε αυτό. Έπειτα μπορούμε να ορίσουμε έναν πίνακα, έστω $$A$$, στον οποίο θα αποθηκεύουμε structs αυτού του τύπου ανάλογα με την είσοδο, αγνοώντας τα τμήματα με μηδενική συχνότητα βλαβών. Αν ταξινομήσουμε τον πίνακα αυτό σε φθίνουσα σειρά με βάση τη συχνότητα βλαβών και επιλύοντας ισοβαθμίες με βάση τον αριθμό τμήματος, τότε οι αριθμοί των τμημάτων των αυτοκινήτων θα έχουν την επιθυμητή σειρά. Η ταξινόμηση αυτή μπορεί να γίνει με [bubblesort](https://en.wikipedia.org/wiki/Bubble_sort). Αυτό σημαίνει ότι θα κάνουμε περάσματα του πίνακα $$A$$ από το τέλος προς την αρχή σταματώντας κάθε φορά μία θέση πιο μετά και αλλάζοντας σειρά στα αταξινόμητα γειτονικά στοιχεία. Μετά από κάθε πέρασμα το στοιχείο αμέσως αριστερά από εκεί που σταματήσαμε είναι το σωστό.

Επειδή απαιτείται ένα διάβασμα των δεδομένων για $$C$$ τμήματα αυτοκινήτου και $$O(L)$$ γραμμικά περάσματα του πίνακα για την ταξινόμηση θα έχουμε χρονική πολυπλοκότητα $$O(C + L^2)$$. Αυτή η πολυπλοκότητα δεν είναι αρκετά καλή και θα χάσουμε αρκετά testcases. Η χωρική πολυπλοκότητα είναι $$O(L)$$, αφού μπορούμε να μην αποθηκεύουμε δεδομένα για τα τμήματα χωρίς βλάβες ευθύνης κατασκευαστή.

```c++
#include <cstdio>
#include <algorithm>
using namespace std;

#define MAXL 10005

struct car_part {
    long id, freq;
};

car_part get(long id, long freq) {
    car_part res;
    res.id = id;
    res.freq = freq;
    return(res);
}

car_part A[MAXL];

int main() {
    freopen("hydrogen.in", "r", stdin);
    freopen("hydrogen.out", "w", stdout);
    long C, L = 0;
    scanf("%ld", &C);
    for (long i = 0; i < C; i++) {
        long id, freq;
        scanf("%ld %ld", &id, &freq);
        // Αποθήκευση δεδομένων για τμήματα με βλάβες ευθύνης κατασκευαστή
        if (freq)
            A[L++] = get(id, freq);
    }
    // Εκτύπωση πλήθους τμημάτων με βλάβες ευθύνης κατασκευαστή
    printf("%ld\n", L);
    // Ταξινόμηση με bubblesort
    for (long i = 0; i < L; i++) {
        // Πέρασμα από δεξιά προς τα αριστερά
        for (long j = L - 1; j > i; j--) {
            // Αντιμετάθεση γειτονικών αταξινόμητων στοιχείων
            if (A[j].freq > A[j - 1].freq || A[j].freq == A[j - 1].freq && A[j].id > A[j - 1].id)
                swap(A[j], A[j - 1]);
        }
        // Εμφάνιση έτοιμων αποτελεσμάτων
        printf("%ld\n", A[i].id);
    }
    return(0);
}
```

## Καλύτερη λύση με Quicksort

Μπορούμε να βελτιώσουμε τον προηγούμενο αλγόριθμο από άποψη χρονικής πολυπλοκότητας, αλλά και από άποψη έκτασης και απλότητας κώδικα, εάν την ταξινόμηση την κάνουμε με χρήση της μεθόδου [quicksort](https://en.wikipedia.org/wiki/Quicksort) μέσω της συνάρτησης sort που είναι υλοποιημένη στη βιβλιοθήκη **algorithm**. Θα χρειαστεί να χρησιμοποιήσουμε μία συνάρτηση σύγκρισης, έστω comp, για να ορίσουμε ότι η ταξινόμηση πρέπει να είναι πρωτίστως φθίνουσα ως προς τη συχνότητα βλαβών λόγω κατασκευαστή και δευτερευόντως αύξουσα ως προς τον αριθμό τμήματος.

Η χρονική πολυπλοκότητα μειώνεται λόγω της νέας μεθόδου ταξινόμησης σε $$O(C + LlogL)$$ που είναι αρκετά καλή για να περάσουμε όλα τα testcases. Η χωρική πολυπλοκότητα είναι και πάλι $$O(L)$$.

```c++
#include <cstdio>
#include <algorithm>
using namespace std;

#define MAXL 10005

struct car_part {
    long id, freq;
};

car_part get(long id, long freq) {
    car_part res;
    res.id = id;
    res.freq = freq;
    return(res);
}

car_part A[MAXL];

bool comp(car_part a, car_part b) {
    return(a.freq > b.freq || a.freq == b.freq && a.id > b.id);
}

int main() {
    freopen("hydrogen.in", "r", stdin);
    freopen("hydrogen.out", "w", stdout);
    long C, L = 0;
    scanf("%ld", &C);
    for (long i = 0; i < C; i++) {
        long id, freq;
        scanf("%ld %ld", &id, &freq);
        // Αποθήκευση δεδομένων για τμήματα με βλάβες ευθύνης κατασκευαστή
        if (freq)
            A[L++] = get(id, freq);
    }
    // Εκτύπωση πλήθους τμημάτων με βλάβες ευθύνης κατασκευαστή
    printf("%ld\n", L);
    // Ταξινόμηση με quicksort
    sort(A, A + L, comp);
    // Εμφάνιση αποτελεσμάτων
    for (long i = 0; i < L; i++) {
        printf("%ld\n", A[i].id);
    }
    return(0);
}
```

## Βέλτιστη λύση με ανάλογο του Radix Sort

Το πρόβλημα μπορεί να λυθεί βέλτιστα εάν κάνουμε την ακόλουθη παρατήρηση.

**Παρατήρηση**: Η μέγιστη δυνατή συχνότητα εμφάνισης βλάβης ευθύνης κατασκευαστή είναι αρκετά μικρή. Το ίδιο ισχύει και για το εύρος των αριθμών τμημάτων των αυτοκινήτων ($$10^4$$).

Μπορούμε επομένως να λύσουμε το πρόβλημα πιο αποδοτικά αν δημιουργήσουμε έναν πίνακα, έστω $$B$$, με μέγεθος $$MAXID + 1$$, όπου MAXID ο μέγιστος αριθμός τμήματος, και σε κάθε θέση του πίνακα αυτού (εκτός από τη $$0$$) αποθηκεύουμε τη συχνότητα βλαβών ευθύνης κατασκευαστή του αντίστοιχου τμήματος. Θα έχουμε επίσης έναν πίνακα διανυσμάτων, έστω $$D$$, με μέγεθος $$MAXF + 1$$, όπου $$MAXF$$ η μέγιστη συχνότητα βλάβης ευθύνης κατασκευαστή, σε κάθε θέση του οποίου θα μπορούμε να έχουμε ένα δυάνυσμα με τους αριθμούς τμημάτων του αυτοκινήτου που παρουσίασαν την αντίστοιχη συχνότητα βλαβών ευθύνης κατασκευαστή. Η κατασκευή των διανυσμάτων του πίνακα $$D$$ μπορεί να γίνει παραθέτοντας στο τέλος του κατάλληλου διανύσματος συχνότητας τους κατάλληλους αριθμούς τμημάτων, καθώς διατρέχουμε τον πίνακα $$B$$ από τα αριστερά προς τα δεξιά. Το τελικό αποτέλεσμα θα προκύψει εμφανίζοντας τα διανύσματα από τα αριστερά προς τα δεξιά, καθώς διατρέχουμε τον πίνακα συχνοτήτων από τα δεξιά προς τα αριστερά. Οι δύο ταξινομήσεις θυμίζουν τη μέθοδο ταξινόμησης [radix sort](https://en.wikipedia.org/wiki/Radix_sort).

Η νέα χρονική πολυπλοκότητα είναι $$O(MAXID + MAXF)$$. Η χωρική πολυπλοκότητα είναι $$O(MAXID + MAXF)$$ καθώς υπάρχει ανάγκη αποθήκευσης των νέων πινάκων που μπορεί να έχουν και κενές θέσεις. Οι όροι $$O(C)$$ και $$O(L)$$ απορροφήθηκαν από τον $$O(MAXID)$$ καθώς είναι πάντα μεγαλύτερος. Η χρονική πολυπλοκότητα αυτή είναι καλύτερη από αυτήν της Quicksort στη χειρότερη περίπτωση και η λύση περνάει όλα τα testcases.

```c++
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

#define MAXID 10000
#define MAXF 10000

long B[MAXID + 5];
vector<long> D[MAXF + 5];

int main() {
    freopen("hydrogen.in", "r", stdin);
    freopen("hydrogen.out", "w", stdout);
    long C, L = 0;
    scanf("%ld", &C);
    for (long i = 0; i < C; i++) {
        long id, freq;
        scanf("%ld %ld", &id, &freq);
        // Ουσιαστικά ταξινόμηση με βάση τον αριθμό τμήματος
        if (freq) {
            L++;
            B[id] = freq;
        }
    }
    // Ταξινόμηση με βάση τη συχνότητα εμφάνισης
    for (long i = 1; i <= MAXID; i++) {
        long freq = B[i];
        D[freq].push_back(i);
    }
    // Εκτύπωση πλήθους τμημάτων με βλάβες ευθύνης κατασκευαστή
    printf("%ld\n", L);
    // Εμφάνιση κατάλληλα ταξινομημένων αριθμών τμημάτων αυτοκινήτου
    for (int i = MAXF; i; i--) {
        for (int j = 0; j < D[i].size(); j++) {
            printf("%ld\n", D[i][j]);
        }
    }
    return(0);
}
```
