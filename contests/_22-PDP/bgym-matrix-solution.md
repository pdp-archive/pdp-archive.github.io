---
layout: solution
codename: matrix
---

## Επεξήγηση εκφώνησης

Μας δίνονται δύο συμβολοσειρές $$A$$ και $$B$$ και μας ζητείται να βρούμε αν (και πού) εμφανίζεται η $$A$$ μέσα στην $$B$$. 

Ξεκινάμε με την brute force λύση που θέλει $$\mathcal{O}(NM)$$ χρόνο και είναι αρκετή για να περάσει όλα τα testcases του προβλήματος. Συνεχίζουμε μετά με τρεις λύσεις που λύνουν το πρόβλημα σε $$\mathcal{O}(N + M)$$ χρόνο. Οι λύσεις αυτές μπορούν να διαβαστούν ανεξάρτητα μεταξύ τους, αν έχετε ήδη κάποιες γνώσεις για τις τεχνικές που χρησιμοποιούν.

## Brute force λύση

Η brute force λύση είναι να δοκιμάσουμε να συγκρίνουμε κάθε δυνατή υποσυμβολοσειρά της $$B$$ με την $$A$$. Πιο συγκεκριμένα, για κάθε θέση $$i = 0, 1, \ldots \lvert B \rvert - N$$ ελέγχουμε αν $$B_{i}B_{i+1} \ldots B_{i + N - 1} = A_0 A_1 \ldots A_{N-1}$$. Ο έλεγχος γίνεται με ένα for loop, το οποίο μπορούμε να σταματήσουμε νωρίς (με break) αν βρούμε ένα στοιχείο που να διαφέρουν οι συμβολοσειρές.

Στην χειρότερη περίπτωση για κάθε $$i$$ η σύγκριση θέλει $$\mathcal{O}(N)$$ χρόνο και αφού υπάρχουν $$M - N + 1$$ δυνατά $$i$$, ο αλγόριθμος χρειάζεται συνολικά $$N \cdot (M - N + 1) = \mathcal{O}(NM)$$ χρόνο.

Ο αλγόριθμος αυτός είναι αρκετά γρηγορος για να περάσει όλα τα testcases. Οι επόμενοι αλγόριθμοι λύνουν το πρόβλημα σε $$\mathcal{O}(N + M)$$ χρόνο.

{% include code.md solution_name='matrix_brute_force.cc' %}

**Σημείωση:** Την ίδια πολυπλοκότητα έχει και ο αλγόριθμος `strstr` της C (ολόκληρος ο κώδικας [εδώ]({% include link_to_source.md source_name='matrix_strstr.cc' %})) και το `std::string::find` της C++. 

## Λύση με Αλγόριθμο Z

*Η λύση αυτή προαπαιτεί γνώσεις για τον αλγόριθμο Z. Μπορείτε να διαβάσετε περισσότερα [εδώ](https://drive.google.com/file/d/1ev5dqBCS5KJU7-042QUEe_GVwtVNhuby/view?usp=sharing) ή [εδώ](https://cp-algorithms.com/string/z-function.html).*

Ο αλγόριθμος Z υπολογίζει για μία συμβολοσειρά $$S$$, τον πίνακα $$Z$$, όπου $$Z[i]$$ είναι το μήκος της μακρύτερης ακολουθίας που ξεκινάει από το $$i$$-οστό στοιχείο και $$A_0 A_1 \ldots A_{Z[i]} = A_{i}A_{i+1} \ldots A_{i + Z[i] - 1}$$. Για παράδειγμα για $$S = \text{αβαβαβααβγαβ}$$, ο πίνακας είναι ο εξής:

![Παράδειγμα πίνακα Ζ για τη συμβολοσειρά αβαβαβααβγαβ, που είναι: 12, 0, 5, 0, 3, 0, 1, 2, 0, 0, 2, 0](/assets/22-bgym-matrix-z-algorithm.svg){:width="500px", .center_image}


Ο αλγόριθμος Z χρειάζεται $$\mathcal{O}(\lvert S\rvert)$$ χρόνο. Τώρα, για να βρούμε αν η $$A$$ εμφανίζεται στη $$B$$, θέτουμε $$S = A + B$$ και βρίσκουμε το μικρότερο $$i > 0$$, ώστε $$Z[i] \geq N$$. Όταν $$Z[i] \geq N$$, σημαίνει ότι $$A = S_0S_1 \ldots S_{N - 1} = S_{i}S_{i+1} \ldots S_{i + Z[i] - 1}$$, που είναι και το ζητούμενο. Άρα αυτό μας επιτρέπει να λύσουμε το πρόβλημα σε $$\mathcal{O}(N + M)$$ χρόνο. 

{% include code.md solution_name='matrix_z_algo.cc' start=25 end=43 %}

Ολόκληρος ο κώδικας βρίσκεται [εδώ]({% include link_to_source.md source_name='matrix_z_algo.cc' %}).

## Λύση με KMP

*Η λύση αυτή προαπαιτεί γνώσεις για τον αλγόριθμο KMP. Μπορείτε να διαβάσετε περισσότερα [εδώ](https://cp-algorithms.com/string/prefix-function.html).*

Έστω $$S$$ μία συμβολοσειρά και για ευκολία ας υποθέσουμε ότι ξεκινάει από το $$1$$. Ο αλγόριθμος KMP υπολογίζει τον πίνακα $$F$$, όπου $$F[0] = -1$$ και $$F[i]$$ για $$i > 0$$ είναι το μήκος της μακρύτερης υποακολουθίας που τελειώνει στο στοιχείο $$i$$ και $$S_1 S_2 \ldots S_{F[i]} = S_{i - F[i] + 1} S_{i - F[i] + 2} \ldots S_{i}$$. Για παράδειγμα για $$S = \text{αβαβαβααβγαβ}$$, ο πίνακας είναι ο εξής:

![Παράδειγμα πίνακα F για τη συμβολοσειρά αβαβαβααβγαβ, που είναι: -1, 0, 0, 1, 2, 3, 4, 5, 1, 2, 0, 1, 2](/assets/22-bgym-matrix-kmp.svg){:width="500px", .center_image}

Ξεκινώντας και τις δύο συμβολοσειρές από την θέση $$1$$, ο κώδικας είναι ο εξής.

{% include code.md solution_name='matrix_kmp.cc' start=27 end=33 %}

Ο αλγόριθμος KMP χρειάζεται $$\mathcal{O}(\lvert S \rvert)$$ χρόνο. Για την εύρεση του $$A$$ στο $$B$$, για κάθε θέση $$j$$ του $$B$$ βρίσκουμε το μακρύτερο prefix του $$A$$, μήκους $$k$$, που είναι suffix του $$B_1 \ldots B_j$$. Αν $$k = N$$, τότε βρήκαμε μία εμφάνιση του $$A$$. Για να υπολογίσουμε το $$k$$ ξεκινάμε από τα αριστερά προς τα δεξιά. Στην αρχή το $$k = 0$$. Στην θέση $$i$$:
 1. Αν $$B[i] = A[k+1]$$, τότε αυξάνουμε το $$k$$ και τερματίζουμε.
 1. Διαφορετικά, αν $$B[i] \neq A[k+1]$$, τότε θέτουμε $$k = F[k]$$, και επιστρέφουμε στο 1.

Όταν έχουμε $$B[i] \neq A[k+1]$$, σημαίνει ότι δεν μπορούμε να επεκτείνουμε το $$A_1 A_2\ldots A_k = B_{i - k + 1} B_{i - k + 2} \ldots B_{i-1}$$ κατά μία θέση. Επομένως, πρέπει να βρούμε ένα μικρότερο suffix του $$B[i]$$ που είναι prefix του $$A$$, χρησιμοποιώντας ότι $$A_1 A_2\ldots A_k = B_{i - k + 1} B_{i - k + 2} \ldots B_{i}$$. Αυτή την τιμή ακριβώς την έχουμε υπολογίσει στο $$F[k]$$, άρα θέτουμε $$k = F[k]$$.

{% include code.md solution_name='matrix_kmp.cc' start=35 end=45 %}

Ολόκληρος ο κώδικας βρίσκεται [εδώ]({% include link_to_source.md source_name='matrix_kmp.cc' %}).

## Λύση με Rolling Hash

*Η λύση αυτή προαπαιτεί γνώσεις για το rolling hash. Μπορείτε να διαβάσετε περισσότερα [εδώ](https://cp-algorithms.com/string/string-hashing.html).*

Για μία ακολουθία $$S$$ με μήκος $$N$$, το rolling hash $$h(S)$$ ορίζεται ως

$$h(S) = S_0 \cdot b^{N-1} + S_1 \cdot b^{N-2} + \ldots + S_{N-2} \cdot b + S_{N-1} \pmod{p}$$

για κάποιον θετικό ακέραιο $$b$$ και έναν πρώτο αριθμό $$p$$. Η ιδέα είναι ότι όταν συγκρίνουμε συμβολοσειρές $$S_1$$ και $$S_2$$ αντί να κοιτάξουμε αν όλοι οι χαρακτήρες είναι ίσοι μεταξύ τους (με $$\lvert S_1 \rvert$$ συγκρίσεις) κοιτάμε μόνο αν $$h(S_1) = h(S_2)$$. Υπάρχει η πιθανότητα ο αλγόριθμος να κάνει λάθος, γιατί μπορεί δύο ακολουθίες να έχουν το ίδιο hash (αφού υπάρχουν μόνο $$p$$ δυνατές τιμές και πολύ περισσότερες συμβολοσειρές). Για να μειώσουμε αυτή την πιθανότητα διαλέγουμε $$p$$ έναν "μεγάλο" πρώτο αριθμό και $$B = 222$$, το εύρος τον πιθανών τιμών. Για να είμαστε σίγουροι ότι ο αλγόριθμος θα δώσει τη σωστή απάντηση, όταν $$h(S_1) = h(S_2)$$ ελέχουμε και αν όντως οι ακολουθίες είναι ίσες. Με τα δοσμένα testcases, δεν κάνει διαφορά άμα προσθέσουμε ή όχι αυτόν τον έλεγχο.

**Παρατήρηση 1η:** Αν στην ακολουθία $$S$$ προσθέσουμε έναν χαρακτήρα $$x$$ στο τέλος της, παίρνοντας την $$S'$$, τότε $$h(S') = h(S) \cdot B + x$$.

*(Αιτιολόγηση)* Γράφοντας τον ορισμό της $$h$$ για την $$S'$$,

$$
\begin{align*}
h(S') & = S_0' \cdot b^{N} + S_1' \cdot b^{N-1} + \ldots + S_{N-1}' \cdot b + S_{N}' \pmod{p} \\
 & = S_0 \cdot b^{N-1} + S_1 \cdot b^{N-2} + \ldots + S_{N-1} \cdot b + x \pmod{p} \\
 & = (S_0 \cdot b^{N-2} + S_1 \cdot b^{N-1} + \ldots + S_{N-1}) \cdot b + x \pmod{p} \\
 & = h(S) \cdot b + x \pmod{p}.
\end{align*}
$$

**Παρατήρηση 2η:** Αν από την ακολουθία $$S$$ αφαιρέσουμε τον πρώτο χαρατήρα, παίρνοντας την $$S'$$, τότε $$h(S') = h(S) - S_0 \cdot b^N \pmod{p}$$.

Συνδυάζοντας αυτές τις δύο παρατηρήσεις, μας επιτρέπει να υπολογίσουμε όλα τα hash των συμβολοσειρών μεγέθους $$N$$ της $$B$$. Πιο συγκεκριμένα ξεκινάμε υπολογίζοντας το $$h(B_0 \ldots B_{N-1})$$ και το $$\text{pow} = b^N \pmod{p}$$. Τώρα γνωρίζοντας το $$h(B_i\ldots B_{i + N - 1})$$, έχουμε ότι $$h(B_{i+1}\ldots B_{i + N}) = h(B_i\ldots B_{i + N - 1}) \cdot b + B_{i + N} - B_i \cdot \text{pow} \pmod{p}$$. Αυτές οι πράξεις θέλουν $$\mathcal{O}(1)$$ χρόνο, και κάθε σύγκριση θέλει $$\mathcal{O}(1)$$ χρόνο, άρα αν δεν υπάρχει λάθος ο αλγόριθμος χρειάζεται $$\mathcal{O}(N)$$ χρόνο.

{% include code.md solution_name='matrix_hash.cc' %}

**Σημείωση:** Με τον έλεγχο στην χειρότερη περίπτωση ο αλγόριθμος χρειάζεται $$\mathcal{O}(N^2)$$ χρόνο.
