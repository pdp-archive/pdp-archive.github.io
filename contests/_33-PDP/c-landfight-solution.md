---
layout: solution
codename: landfight
---


## Πολύ αργή λύση (brute force)
Η πιο απλή λύση είναι για κάθε $$L$$, να ελέγξουμε όλα τα δυνατά $$R$$. Για να αθροίσουμε τα πρώτα $$L$$ στοιχεία $$x_1+x_2+\dots+x_L$$ θα κάνουμε ένα ακόμα for, άρα συνολική πολυπλοκότητα $$\mathcal{O}(N^3)$$.

{% include code.md solution_name='landfight_brute.cc' %} 


## Λύση με χρήση prefix sums (20% της βαθμολογίας)
Στην παρακάνω λύση αποφεύγουμε τα loop υπολογισμού αθροισμάτων κάνοντας προϋπολογισμό των prefix sums σε έναν πίνακα $$\mathit{PS}$$, δηλαδή 

$$\mathit{PS}_i=x_1+x_2+ \dots + x_i=\sum_{j=1}^i {A_j}$$ 

Αντίστοιχα, θα χρειαστούμε και τα suffix sums[^1] για το άθροισμα των τελευταίων $$R$$ στοιχείων σε έναν πίνακα $$\mathit{SS}$$ με 

$$\mathit{SS}_i=x_i+x_{i+1}+\dots+x_N=\sum_{j=i}^N{A_j}$$ 

Χρειάζεται προσοχή στην ειδική περίπτωση που το άθροισμα όλων των στοιχείων είναι $$0$$. Στην περίπτωση αυτή το $$\mathit{PS}_N=0$$ και ο αριστερός τσιφλικάς θα πάρει όλα τα χωράφια ενώ ο δεξιός δεν θα πάρει κανένα. Η ιδιόμορφη αυτή περίπτωση είναι αποδεκτή και έχει απάντηση $$0$$. Για την περίπτωση αυτή στον πίνακα των suffix sums προσθέτουμε μια επιπλέον θέση με τιμή $$0$$ στη θέση $$\mathit{SS}_{N+1}$$.
Συνολική πολυπλοκότητα της λύσης είναι $$\mathcal{O}(N^2)$$.

{% include code.md solution_name='landfight_brute_ps.cc' %} 

Στην παραπάνω λύση, μπορεί να γίνει μια μικρή βελτίωση στο εσωτερικό loop. Όταν έχουμε υπολογίσει κάποια τιμή $$\mathit{ans}$$ έως τώρα, δεν μας ενδιαφέρει να ελέγχουμε τιμές χειρότερες από την τιμή αυτή. Το δεύτερο loop μπορεί να γραφτεί ως:
```c++
    for(long j=i+1,n2=min(N,ans+i+1);j<n2;j++)
```

## Λύση με χρήση δύο pointers (70% της βαθμολογίας)

Σύμφωνα με τους περιορισμούς της εκφώνησης, για περιπτώσεις ελέγχου συνολικής αξίας 70% έχουμε μόνο μη μηδενικές θετικές τιμές για τα $$x_i$$. Αποτέλεσμα αυτού, είναι τόσο τα prefix sums όσο και τα suffix sums να αποτελούν γνησίως μονότονες ακολουθίες εφόσον:

$$\mathit{PS}_{i+1}=\mathit{PS}_i+x_{i+1} > \mathit{PS}_i$$

$$\mathit{SS}_i=\mathit{SS}_{i+1}+x_i > \mathit{SS}_{i+1}$$


**Παρατήρηση:** <br>
Εφόσον οι δύο ακολουθίες είναι γνησίως μονότονες, για κάθε σημείο της μιας ακολουθίας θα υπάρχει το πολύ ένα σημείο της άλλης που θα έχει ίδια τιμή.

**Απόδειξη:** <br>
Έστω ότι υπάρχουν δυο κοινά σημεία των δύο ακολουθιών στις θέσεις $$i$$ και $$j$$ με $$i<j$$ άρα $$\mathit{PS}_{i}=\mathit{SS}_{i}=\mathit{PS}_{j}=\mathit{SS}_{j}$$. Εφόσον $$i<j$$ και οι ακολουθίες είναι γνησίως μονότονες, τότε $$\mathit{PS}_{i} \lt \mathit{PS}_{j}$$ πράγμα άτοπο. 

Παρατηρήστε το παρακάτω σχήμα που αντιστοιχεί στο πρώτο παράδειγμα της εκφώνησης:

<center>
<img alt="Διάγραμμα με την τιμή του prefix και suffix sum για κάθε i" src="/assets/33-pdp-c-landfight-bs1.svg" width="400px">
</center>

Οι πράσινες κουκίδες αντιστοιχούν στην ακολουθία των prefix sums και οι μωβ στα suffix sums. Μας ενδιαφέρει να εντοπίσουμε τιμές του κατακόρυφου άξονα (τιμές sum) που να υπάρχουν και στις δύο ακολουθίες. Τέτοιες τιμές είναι οι $$0$$,$$10$$,$$18$$ και $$28$$. Από αυτές αποδεκτές είναι μόνο η τιμή $$0$$ (με απάντηση $$7$$ αδιάθετα χωράφια) και η $$10$$ (με απάντηση $$2$$ αδιάθετα χωράφια). Οι τιμές $$18$$ και $$28$$ βρίσκονται μετά τη διασταύρωση των δυο ακολουθιών και απορρίπτονται διότι τα χωράφια του ενός τσιφλικά έχουν υπερκαλύψει χωράφια του άλλου. 

Οπότε αρκεί να χρησιμοποιήσουμε δύο δείκτες, έναν για το prefix sum και έναν για το suffix sum και να τους μετακινούμε έτσι ώστε να βρούμε όλους τους συνδυασμούς όπου το suffix sum στον ένα δείκτη είναι ίσο με το prefix sum στον άλλο δείκτη. Σταματάμε όταν οι δείκτες διασταυρωθούν. 
Η πολυπλοκότητα της λύσης είναι $$\mathcal{O}(N)$$ καθώς κάθε δείκτης μπορεί να αλλάξει το πολύ $$N$$ φορές και σε κάθε βήμα αλλάζουμε έναν δείκτη. 

{% include code.md solution_name='landfight_2pointers.cc' %} 


## Λύση με δυαδική αναζήτηση στα suffix sums (100% της βαθμολογίας)

Για κάθε δυνατό πλήθος αριστερών χωραφιών θέλουμε να ελέγξουμε μόνο τα suffix sums με ίδια τιμή. Ας ταξινομήσουμε αυτά τα suffix sums, διατηρώντας τις θέσεις που αυτά εμφανίστηκαν, ώστε να μπορούμε να κάνουμε δυαδική αναζήτηση σε αυτά. Δηλαδή για κάθε πλήθος $$i$$ χωραφιών του αριστερού τσιφλικά με prefix sum $$\mathit{PS}_i$$, ψάχνουμε τις θέσεις που εμφανίζονται suffix sums με $$\mathit{SS}_j=\mathit{PS}_i$$ και $$i\lt j$$. 
Θα χρησιμοποιήσουμε έναν πίνακα με *pair* από τη βιβλιοθήκη *stl* της *C++*, όπου αποδίδουμε στο πρώτο στοιχείο του την τιμή του suffix sum $$\mathit{SS}_i$$ και στο δεύτερο τη θέση $$i$$ που βρέθηκε το suffix sum αυτό. Η ταξινόμηση στα *pair* γίνεται με το πρώτο στοιχείο και σε περίπτωση ισότητας και με το δεύτερο.
Συνολική πολυπλοκότητα της λύσης είναι $$\mathcal{O}(N\cdot \log{N})$$.

{% include code.md solution_name='landfight_bsearch.cc' %} 

## Λύση με χρήση αραιού πίνακα από δομές αποθήκευσης (100% της βαθμολογίας)

Γνώσεις που θα χρειαστούμε: [unordered_map](https://kallinikos.github.io/STL), [stack](https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29)

Αντί να βάλουμε τα suffix sums σε έναν πίνακα και να τον ταξινομήσουμε, θα μπορούσαμε να τα έχουμε σε έναν δισδιάστατο πίνακα όπου η πρώτη διάσταση είναι η τιμή του suffix sum και στη δεύτερη διάσταση του θα έχουμε τις θέσεις που συναντήσαμε το suffix sum. Οι τιμές των suffix sum όμως δεν είναι συνεχείς και μπορεί να έχουν τιμές από $$-10^9$$ έως $$10^9$$ σύμφωνα με τους περιορισμούς της εκφώνησης του προβλήματος. Ο συνολικός αριθμός των διαφορετικών τιμών δεν μπορεί όμως να ξεπεράσει το $$N$$, άρα χρειαζόμαστε μια δομή να αποθηκεύσουμε έναν αραιό πίνακα από πίνακες όπως το *map* ή το *unordered_map* που περιέχονται στην *stl* της *C++*.

**Παράδειγμα:** 
```c++
    unordered_map<long, vector<long>> M;
    M[0].push_back(N+1);//περίπτωση L=N,R=0
    for(long sum=0,k=N;k>0;k--){
        sum += A[k];
        M[sum].push_back(k);
    }
```
**Παρατήρηση:**
Στον κάθε πίνακα *vector*, οι θέσεις $$k$$ που αποθηκεύονται μειώνονται σε κάθε βήμα της επανάληψης καθώς υπολογίζουμε τα suffix sums από τη θέση $$N$$ προς τη θέση $$1$$. Άρα κάθε *vector* περιέχει μια γνησίως φθίνουσα ακολουθία.

Ας δούμε ένα παράδειγμα με το ακόλουθο test case:

| **landfight.in**      |
| :---  | :--- |
|   11 <br> -3 -5 5 4 -9 5 -2 -1 0 3 7 |
{:.table_with_borders.table_with_monospace_font}

Το παρακάτω διάγραμμα αναπαριστά την ακολουθία των suffix sums

<center>
<img alt="suffix sum diagram" src="/assets/33-pdp-c-landfight-bs2.svg" width="560px">
</center>

και αποθηκεύεται στο *unordered_map* (πράσινα κελιά) από *vectors* (κίτρινα κελιά) του παρακάτω σχήματος, αναπαριστώντας έναν δισδιάστατο αραιό πίνακα

<center>
<img alt="dim2 sparse array" src="/assets/33-pdp-c-landfight-bs3.svg" width="340px">
</center>


Μια απλοποιημένη και μη αποδοτική αναζήτηση[^3] της απάντησης του προβλήματος, μπορεί να γίνει ως εξής:
```c++
    long ans = N;
    for(long prefix=0,i=1;i<=N;i++){
        prefix += A[i];
        for(long j:M[prefix]){
            if(j>i)
                ans = min(ans,j-i-1);
        }
    }
```
Αρκεί να παρατηρήσουμε ότι καθώς το $$i$$ αυξάνεται, οι τιμές του κάθε *vector* που είναι μικρότερες ή ίσες από το $$i$$ δεν θα χρησιμοποιηθούν ξανά και μπορούμε να τις αγνοήσουμε[^4] ή να τις διαγράψουμε. Στο *vector* η διαγραφή γενικά δεν είναι αποδοτική εκτός αν διαγράφουμε το (ή τα) τελευταία στοιχεία του, όπως συμβαίνει στην περίπτωση μας.
 
Μια λύση με *vector* ακολουθεί:

{% include code.md solution_name='landfight_vector.cc' %}

Αντί για *vector* μπορούμε να χρησιμοποιήσουμε και άλλες δομές που μας επιτρέπουν διαγραφή στοιχείων όπως η διπλά συνδεδεμένη λίστα[^5] ή το *stack*[^6].

Η συνολική πολυπλοκότητα των παραπάνω λύσεων είναι amortized $$\mathcal{O}(N)$$ καθώς κάθε αποθηκευμένη στη δομή μας θέση $$i$$, θα την εξετάσουμε το πολύ μια φορά και θα τη διαγράψουμε. 

[^1]: Η ύπαρξη των suffix sum κάνει πιο κατανοητό τον κώδικα αλλά δεν είναι απαραίτητη, διότι: $$SS_i = PS_{n}-PS_{i-1}$$ 

[^3]: Ο απλοποιημένος αυτός κώδικας δεν είναι αποδοτικός και έχει πολυπλοκότητα $$\mathcal{O}(N^2)$$ καθώς μπορεί για παράδειγμα ένα test case να έχει όλα τα $$x_i=0$$ οπότε το *vector* στη θέση $$M_0$$ θα έχει $$N$$ στοιχεία. Ένα ακόμα πρόβλημα του παραπάνω κώδικα είναι ότι δεν ελέγχει αν υπάρχει το στοιχείο $$M_{\mathit{prefix}}$$ πριν το χρησιμοποιήσει, με αποτέλεσμα τη δημιουργία κενών στοιχείων στο *unordered_map*. 

[^4]: [Ενδεικτική λύση με vector χωρίς διαγραφή στοιχείων]({% link_to_source='landfight_vector_head.cc' %}) 

[^5]: [Ενδεικτική λύση με διπλά συνδεδεμένη λίστα]({% link_to_source='landfight_list.cc' %})

[^6]:[Ενδεικτική λύση με stack]({% link_to_source='landfight_stack.cc' %})

