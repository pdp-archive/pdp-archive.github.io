---
layout: solution
codename: wayhome
---

## Εισαγωγή

Έχουμε ένα γράφο με μορφή πλέγματος (grid) και η κίνηση γίνεται οριζόντια και κάθετα στους διπλανούς κόμβους. Ενδέχεται να υπάρχουν απαγορευμένοι κόμβοι(κτίρια) που δεν μπορούμε να επισκεφτούμε.
Στο γράφο αυτό κινούμαστε ταυτόχρονα με έναν αστυνομικό και θέλουμε να φτάσουμε στην έξοδο (σπίτι) χωρίς να καταφέρει ο αστυνομικός να μας δει. Δεν ξέρουμε ποια διαδρομή θα ακολουθήσει ο αστυνομικός και πρέπει να σχεδιάσουμε τη διαδρομή σύμφωνα με την πιο απαισιόδοξη για εμάς κίνηση του αστυνομικού.

## Λύση με απλή μέτρηση αποστάσεων (17% της βαθμολογίας)

Στο subtask αυτό δεν υπάρχουν εμπόδια.

**Παρατήρηση 1:** ο αστυνομικός δεν μας ενδιαφέρει πότε θα φτάσει σε κανένα άλλο σημείο, παρά μόνο, πότε θα είναι σε θέση να εποπτεύει το σπίτι μας. Αρκεί δηλαδή να μετακινηθεί μόνο οριζόντια ή μόνο κάθετα ώστε να φτάσει στη γραμμή ή στήλη του σπιτιού. Εμείς αντίθετα πρέπει να φτάσουμε στο σπίτι. Ακόμα και αν δηλαδή ο αστυνομικός βρίσκεται ανάμεσα σε εμάς και στο σπίτι, δεν έχει σημασία να βρούμε σε ποιο σημείο της διαδρομής μας θα μας δει, καθώς σίγουρα θα φτάσει να εποπτεύει το σπίτι πριν φτάσουμε εμείς εκεί.

**Απόδειξη:** Ας ονομάσουμε 
$$(R_\mathit{home},C_\mathit{home})$$ τη γραμμή και τη στήλη του σπιτιού. 
Έστω ότι ο αστυνομικός θα μπορέσει να μας δει στη στήλη[^1] $$C_\mathit{you}$$, 
πριν φτάσουμε στο σπίτι, την ώρα που θα βρισκόμαστε στο σημείο $$(R_\mathit{you},C_\mathit{you})$$.
Τότε για τον αστυνομικό, ο απαιτούμενος χρόνος να φτάσει από τη στήλη $$C_\mathit{you}$$ 
στη στήλη επόπτευσης του σπιτιού, είναι $$t_\mathit{pol} = \mid C_\mathit{home} - C_\mathit{you}\mid$$ 
ενώ για εμάς είναι $$t_\mathit{you} = \mid C_\mathit{home} - C_\mathit{you} \mid + \mid R_\mathit{home}-R_\mathit{you} \mid \Rightarrow t_\mathit{you} = t_\mathit{pol} + \mid R_\mathit{home}-R_\mathit{you} \mid \Rightarrow t_\mathit{you} \ge t_\mathit{pol}$$ (εφόσον $$\mid R_\mathit{home}-R_\mathit{you} \mid \ge 0$$). Άρα αν ο αστυνομικός μπορεί να μας δει σε οποιοδήποτε σημείο της διαδρομής, θα μας δει και την ώρα που φτάνουμε στο σπίτι οπότε για να λύσουμε το subtask αυτό, αρκεί να ελέγξουμε μόνο αν μπορούμε να φτάσουμε στο σπίτι πριν το εποπτεύσει ο αστυνομικός.

**Παρατήρηση 2:** πρέπει να κινηθούμε όσο γρηγορότερα γίνεται για να φτάσουμε στο σπίτι. Άρα δεν συμφέρει να κάνουμε περιττά βήματα ώστε να αποφύγουμε τον αστυνομικό καθώς θα χάσουμε περισσότερο χρόνο και δεν θα μπορέσουμε να μπούμε με ασφάλεια στο σπίτι.

Η διαδρομή που θα κάνουμε εμείς, θα είναι μια ευθύγραμμη κίνηση (αν βρισκόμαστε στην ίδια γραμμή ή στήλη με το σπίτι) ή δυο ευθύγραμμες κινήσεις (μια οριζόντια και μια κατακόρυφη). Το άθροισμα της κατακόρυφης και οριζόντια απόστασης που θα διανύσουμε, ονομάζεται απόσταση Manhattan.

Ο υπολογισμός της απάντησης γίνεται σε $$\mathcal{O}(1)$$ χρόνο. Η συνολική πολυπλοκότητα είναι $$\mathcal{O}(N\cdot M\cdot (N+M))$$ λόγω της ανάγνωσης των δεδομένων εισόδου. 

{% include code.md solution_name='wayhome_nobuildings.cc' %} 

## Λύση με διπλό bfs και ενημέρωση γραμμών/στηλών με βρόγχο (42% της βαθμολογίας)

Θα κάνουμε δυο διασχίσεις του γράφου, μια για τον αστυνομικό και μια για εμάς.
Στην πρώτη διάσχιση, ο αστυνομικός μπορεί να επισκεφτεί κάθε κελί ή να το εποπτεύσει από απόσταση αν οριζόντια ή κάθετα από τη θέση του δεν παρεμβάλλεται κτίριο.
Στόχος μας είναι να υπολογίσουμε τον ελάχιστο χρόνο που χρειάζεται ο αστυνομικός για να φτάσει σε κάθε κελί και τον ελάχιστο χρόνο για να εποπτεύσει το κάθε κελί.
Επόμενο βήμα είναι να προσπαθήσουμε να φτάσουμε από τη θέση που βρισκόμαστε εμείς, στο κελί τερματισμού, περνώντας από οποιαδήποτε κελιά απαιτείται, αρκεί να τα επισκεφτούμε πριν το χρόνο που ο αστυνομικός μπορεί να τα επισκεφτεί η τα εποπτεύσει.

Εφόσον έχει σημασία να μετράμε τα βήματα μας από την αρχική θέση, θα ακολουθήσουμε μέθοδο bfs (αναζήτηση κατά πλάτος) ώστε να εξερευνούμε πρώτα όλες τις κινήσεις μια τιμής χρόνου (βάθους) $$i$$ πριν πάμε στην επόμενη $$i+1$$.

Εκτελούμε ένα bfs για τον αστυνομικό και σε κάθε θέση που φτάνει, ενημερώνουμε τα κελιά της οριζόντιας και κατακόρυφης ακμής για το χρόνο επόπτευσης.
Το bfs έχει πολυπλοκότητα $$\mathcal{O}(N\cdot M)$$ και για κάθε ένα κελί που επισκεπτόμαστε, θα χρειαστούμε επιπλέον $$\mathcal{O}(N+M)$$ χρόνο για τις ενημερώσεις.
Συνολική πολυπλοκότητα $$\mathcal{O}(N\cdot M\cdot (N+M))$$

{% include code.md solution_name='wayhome_42.cc' %} 

## Λύση με flood fill + διπλό bfs (100% της βαθμολογίας)

Μπορούμε να αποφύγουμε τα loop ενημέρωσης όλων των κελιών της οριζόντιας και κατακόρυφης γραμμής κάθε επισκεπτόμενου κελιού αν έχουμε φροντίσει να τα αποδώσουμε σε εκπροσώπους με τον αλγόριθμο flood fill[^2]. Κάνουμε ένα διπλό loop ώστε για κάθε κελί που δεν έχει εκπρόσωπο, του αποδίδουμε τον επόμενο ελεύθερο και κάνουμε δύο ακόμα loop ώστε να βρούμε και τα υπόλοιπα κελιά που έχουν οπτική επαφή με αυτό οριζόντια ή κάθετα (άρα ανήκουν στην ίδια ομάδα με τον ίδιο εκπρόσωπο). Συνολικά για τα $$N\cdot M$$ κελιά θα αποδοθούν εκπρόσωποι σε $$N\cdot M$$ κελιά άρα έχουμε amortized πολυπλοκότητα $$\mathcal{O}(N\cdot M)$$. Συνολική πολυπλοκότητα λύσης: $$\mathcal{O}(N\cdot M)$$. 

{% include code.md solution_name='wayhome_proxy.cc' start=49 end=129%} 


## Λύση με διπλό bfs optimized (100% της βαθμολογίας)

Αντί να ενημερώνουμε όλα τα κελιά της οριζόντιας και κατακόρυφης ομάδας, αρκεί να σκεφτούμε ότι όλοι οι κόμβοι με χρόνο επίσκεψης/βάθος $$i$$ θα έχουν ενημερωθεί πριν τους κόμβους με χρόνο επίσκεψης/βάθος $$i+1$$. 
Διαχωρίζοντας τις χρονικές τιμές επίσκεψης και επίβλεψης, έχουμε δυνατότητα να εξερευνούμε αποδίδοντας νέες τιμές επίσκεψης και ταυτόχρονα να διαδίδουμε (propagate) τις τιμές επίβλεψης που έχουν οι γειτονικοί μας κόμβοι.  
Η διαδικασία αυτή είναι μια παραλλαγή του γνωστού lazy propagation που χρησιμοποιούμε σε πολλές δομές αποθήκευσης γράφων και δέντρων.

{% include code.md solution_name='wayhome_complete.cc' start=40 end=96 %} 

[^1]: αντίστοιχη είναι η απόδειξη αν μας δει στη γραμμή $$R_\mathit{you}$$. 
[^2]: εναλλακτικά μπορούμε να χρησιμοποιήσουμε και τη δομή union-find για να αποδόσουμε εκπροσώπους.
